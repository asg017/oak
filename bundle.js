(function (child_process, events, fs, util, path, os) {
    'use strict';

    var fs__default = 'default' in fs ? fs['default'] : fs;
    util = util && util.hasOwnProperty('default') ? util['default'] : util;
    path = path && path.hasOwnProperty('default') ? path['default'] : path;
    os = os && os.hasOwnProperty('default') ? os['default'] : os;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    // Reserved word lists for various dialects of the language

    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };

    // And the keywords

    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

    var keywords = {
      5: ecma5AndLessKeywords,
      6: ecma5AndLessKeywords + " const class extends export import super"
    };

    var keywordRelationalOperator = /^in(stanceof)?$/;

    // ## Character categories

    // Big ugly regular expressions that match characters in the
    // whitespace, identifier, and identifier-start categories. These
    // are only applied when a character is found to actually have a
    // code point above 128.
    // Generated by `bin/generate-identifier-regex.js`.
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
    var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range. They were
    // generated by bin/generate-identifier-regex.js

    // eslint-disable-next-line comma-spacing
    var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

    // eslint-disable-next-line comma-spacing
    var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) { return false }
        pos += set[i + 1];
        if (pos >= code) { return true }
      }
    }

    // Test whether a given character code starts an identifier.

    function isIdentifierStart(code, astral) {
      if (code < 65) { return code === 36 }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes)
    }

    // Test whether a given character is part of an identifier.

    function isIdentifierChar(code, astral) {
      if (code < 48) { return code === 36 }
      if (code < 58) { return true }
      if (code < 65) { return false }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
    }

    // ## Token types

    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.

    // All token type variables start with an underscore, to make them
    // easy to recognize.

    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.

    var TokenType = function TokenType(label, conf) {
      if ( conf === void 0 ) conf = {};

      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };

    function binop(name, prec) {
      return new TokenType(name, {beforeExpr: true, binop: prec})
    }
    var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

    // Map keyword names to token types.

    var keywords$1 = {};

    // Succinct definitions of keyword token types
    function kw(name, options) {
      if ( options === void 0 ) options = {};

      options.keyword = name;
      return keywords$1[name] = new TokenType(name, options)
    }

    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),

      // Punctuation token types.
      bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.

      eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
      assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
      incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
      prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", {beforeExpr: true}),

      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", {isLoop: true, beforeExpr: true}),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", {isLoop: true}),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", {isLoop: true}),
      _with: kw("with"),
      _new: kw("new", {beforeExpr: true, startsExpr: true}),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", {beforeExpr: true, binop: 7}),
      _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
      _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
      _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
      _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
    };

    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.

    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");

    function isNewLine(code, ecma2019String) {
      return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
    }

    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;

    // Checks if an object has a property.

    function has(obj, propName) {
      return hasOwnProperty.call(obj, propName)
    }

    var isArray = Array.isArray || (function (obj) { return (
      toString.call(obj) === "[object Array]"
    ); });

    function wordsRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
    }

    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.

    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };

    Position.prototype.offset = function offset (n) {
      return new Position(this.line, this.column + n)
    };

    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) { this.source = p.sourceFile; }
    };

    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.

    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur)
        }
      }
    }

    // A second optional argument can be given to further configure
    // the parser process. These options are recognized:

    var defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
      // (2019). This influences support for strict mode, the set of
      // reserved words, and support for new syntax features. The default
      // is 9.
      ecmaVersion: 9,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // the position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program.
      allowImportExportEverywhere: false,
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: false,
      // When enabled, hashbang directive in the beginning of file
      // is allowed and treated as a line comment.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callback—that will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callback—that will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };

    // Interpret and default an options object

    function getOptions(opts) {
      var options = {};

      for (var opt in defaultOptions)
        { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

      if (options.ecmaVersion >= 2015)
        { options.ecmaVersion -= 2009; }

      if (options.allowReserved == null)
        { options.allowReserved = options.ecmaVersion < 5; }

      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function (token) { return tokens.push(token); };
      }
      if (isArray(options.onComment))
        { options.onComment = pushComment(options, options.onComment); }

      return options
    }

    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations)
          { comment.loc = new SourceLocation(this, startLoc, endLoc); }
        if (options.ranges)
          { comment.range = [start, end]; }
        array.push(comment);
      }
    }

    // Each scope gets a bitset that may contain these flags
    var
        SCOPE_TOP = 1,
        SCOPE_FUNCTION = 2,
        SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
        SCOPE_ASYNC = 4,
        SCOPE_GENERATOR = 8,
        SCOPE_ARROW = 16,
        SCOPE_SIMPLE_CATCH = 32,
        SCOPE_SUPER = 64,
        SCOPE_DIRECT_SUPER = 128;

    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
    }

    // Used in checkLVal and declareName to determine the type of a binding
    var
        BIND_NONE = 0, // Not a binding
        BIND_VAR = 1, // Var-style binding
        BIND_LEXICAL = 2, // Let- or const-style binding
        BIND_FUNCTION = 3, // Function declaration
        BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
        BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        for (var v = options.ecmaVersion;; v--)
          { if (reserved = reservedWords[v]) { break } }
        if (options.sourceType === "module") { reserved += " await"; }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);

      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
      this.containsEsc = false;

      // Set up token state

      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }

      // Properties of the current token:
      // Its type
      this.type = types.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = this.curPosition();

      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;

      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;

      // Figure out if it's a module code.
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);

      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;

      // Positions to delayed-check that yield/await does not exist in default parameters.
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      // Labels in scope.
      this.labels = [];
      // Thus-far undefined exports.
      this.undefinedExports = {};

      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
        { this.skipLineComment(2); }

      // Scope tracking for duplicate variable names (see scope.js)
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);

      // For RegExp validation
      this.regexpState = null;
    };

    var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

    Parser.prototype.parse = function parse () {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node)
    };

    prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
    prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
    prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
    prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
    prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
    prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

    // Switch to a getter for 7.0.0.
    Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

    Parser.extend = function extend () {
        var plugins = [], len = arguments.length;
        while ( len-- ) plugins[ len ] = arguments[ len ];

      var cls = this;
      for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
      return cls
    };

    Parser.parse = function parse (input, options) {
      return new this(options, input).parse()
    };

    Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression()
    };

    Parser.tokenizer = function tokenizer (input, options) {
      return new this(options, input)
    };

    Object.defineProperties( Parser.prototype, prototypeAccessors );

    var pp = Parser.prototype;

    // ## Parser utilities

    var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
    pp.strictDirective = function(start) {
      for (;;) {
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) { return false }
        if ((match[1] || match[2]) === "use strict") { return true }
        start += match[0].length;

        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";")
          { start++; }
      }
    };

    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.

    pp.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true
      } else {
        return false
      }
    };

    // Tests whether parsed token is a contextual keyword.

    pp.isContextual = function(name) {
      return this.type === types.name && this.value === name && !this.containsEsc
    };

    // Consumes contextual keyword if possible.

    pp.eatContextual = function(name) {
      if (!this.isContextual(name)) { return false }
      this.next();
      return true
    };

    // Asserts that following token is given contextual keyword.

    pp.expectContextual = function(name) {
      if (!this.eatContextual(name)) { this.unexpected(); }
    };

    // Test whether a semicolon can be inserted at the current position.

    pp.canInsertSemicolon = function() {
      return this.type === types.eof ||
        this.type === types.braceR ||
        lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    pp.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
        return true
      }
    };

    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.

    pp.semicolon = function() {
      if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
    };

    pp.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma)
          { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
        if (!notNext)
          { this.next(); }
        return true
      }
    };

    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.

    pp.expect = function(type) {
      this.eat(type) || this.unexpected();
    };

    // Raise an unexpected token error.

    pp.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };

    function DestructuringErrors() {
      this.shorthandAssign =
      this.trailingComma =
      this.parenthesizedAssign =
      this.parenthesizedBind =
      this.doubleProto =
        -1;
    }

    pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) { return }
      if (refDestructuringErrors.trailingComma > -1)
        { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
    };

    pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) { return false }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
      if (shorthandAssign >= 0)
        { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
      if (doubleProto >= 0)
        { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
    };

    pp.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
      if (this.awaitPos)
        { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
    };

    pp.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression")
        { return this.isSimpleAssignTarget(expr.expression) }
      return expr.type === "Identifier" || expr.type === "MemberExpression"
    };

    var pp$1 = Parser.prototype;

    // ### Statement parsing

    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.

    pp$1.parseTopLevel = function(node) {
      var exports = {};
      if (!node.body) { node.body = []; }
      while (this.type !== types.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule)
        { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
          {
            var name = list[i];

            this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
          } }
      this.adaptDirectivePrologue(node.body);
      this.next();
      if (this.options.ecmaVersion >= 6) {
        node.sourceType = this.options.sourceType;
      }
      return this.finishNode(node, "Program")
    };

    var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

    pp$1.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      // For ambiguous cases, determine if a LexicalDeclaration (or only a
      // Statement) is allowed here. If context is not empty then only a Statement
      // is allowed. However, `let [` is an explicit negative lookahead for
      // ExpressionStatement, so special-case it first.
      if (nextCh === 91) { return true } // '['
      if (context) { return false }

      if (nextCh === 123) { return true } // '{'
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) { return true }
      }
      return false
    };

    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$1.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        { return false }

      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      return !lineBreak.test(this.input.slice(this.pos, next)) &&
        this.input.slice(next, next + 8) === "function" &&
        (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
    };

    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.

    pp$1.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.

      switch (starttype) {
      case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
      case types._debugger: return this.parseDebuggerStatement(node)
      case types._do: return this.parseDoStatement(node)
      case types._for: return this.parseForStatement(node)
      case types._function:
        // Function as sole body of either an if statement or a labeled statement
        // works, but not when it is part of a labeled statement that is the sole
        // body of an if statement.
        if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
        return this.parseFunctionStatement(node, false, !context)
      case types._class:
        if (context) { this.unexpected(); }
        return this.parseClass(node, true)
      case types._if: return this.parseIfStatement(node)
      case types._return: return this.parseReturnStatement(node)
      case types._switch: return this.parseSwitchStatement(node)
      case types._throw: return this.parseThrowStatement(node)
      case types._try: return this.parseTryStatement(node)
      case types._const: case types._var:
        kind = kind || this.value;
        if (context && kind !== "var") { this.unexpected(); }
        return this.parseVarStatement(node, kind)
      case types._while: return this.parseWhileStatement(node)
      case types._with: return this.parseWithStatement(node)
      case types.braceL: return this.parseBlock(true, node)
      case types.semi: return this.parseEmptyStatement(node)
      case types._export:
      case types._import:
        if (this.options.ecmaVersion > 10 && starttype === types._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40) // '('
            { return this.parseExpressionStatement(node, this.parseExpression()) }
        }

        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
          if (!this.inModule)
            { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
        }
        return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction()) {
          if (context) { this.unexpected(); }
          this.next();
          return this.parseFunctionStatement(node, true, !context)
        }

        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
          { return this.parseLabeledStatement(node, maybeName, expr, context) }
        else { return this.parseExpressionStatement(node, expr) }
      }
    };

    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
      else if (this.type !== types.name) { this.unexpected(); }
      else {
        node.label = this.parseIdent();
        this.semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
          if (node.label && isBreak) { break }
        }
      }
      if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
    };

    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement")
    };

    pp$1.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6)
        { this.eat(types.semi); }
      else
        { this.semicolon(); }
      return this.finishNode(node, "DoWhileStatement")
    };

    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.

    pp$1.parseForStatement = function(node) {
      this.next();
      var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types.parenL);
      if (this.type === types.semi) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, null)
      }
      var isLet = this.isLet();
      if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) { this.unexpected(awaitAt); }
            } else { node.await = awaitAt > -1; }
          }
          return this.parseForIn(node, init$1)
        }
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, init$1)
      }
      var refDestructuringErrors = new DestructuringErrors;
      var init = this.parseExpression(true, refDestructuringErrors);
      if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init)
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init)
    };

    pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
    };

    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      // allow function declarations in branches, but only in non-strict mode
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement")
    };

    pp$1.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        { this.raise(this.start, "'return' outside of function"); }
      this.next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
      else { node.argument = this.parseExpression(); this.semicolon(); }
      return this.finishNode(node, "ReturnStatement")
    };

    pp$1.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      var cur;
      for (var sawDefault = false; this.type !== types.braceR;) {
        if (this.type === types._case || this.type === types._default) {
          var isCase = this.type === types._case;
          if (cur) { this.finishNode(cur, "SwitchCase"); }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types.colon);
        } else {
          if (!cur) { this.unexpected(); }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement")
    };

    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
        { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement")
    };

    // Reused empty array added for node fields that are always empty.

    var empty = [];

    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types.parenR);
        } else {
          if (this.options.ecmaVersion < 10) { this.unexpected(); }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer)
        { this.raise(node.start, "Missing catch or finally clause"); }
      return this.finishNode(node, "TryStatement")
    };

    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    };

    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement")
    };

    pp$1.parseWithStatement = function(node) {
      if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement")
    };

    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement")
    };

    pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
        {
        var label = list[i$1];

        if (label.name === maybeName)
          { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      } }
      var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          // Update information about previous labels on this node
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else { break }
      }
      this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement")
    };

    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement")
    };

    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).

    pp$1.parseBlock = function(createNewLexicalScope, node) {
      if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
      if ( node === void 0 ) node = this.startNode();

      node.body = [];
      this.expect(types.braceL);
      if (createNewLexicalScope) { this.enterScope(0); }
      while (!this.eat(types.braceR)) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (createNewLexicalScope) { this.exitScope(); }
      return this.finishNode(node, "BlockStatement")
    };

    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.

    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.type === types.semi ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.type === types.parenR ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement")
    };

    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.

    pp$1.parseForIn = function(node, init) {
      var isForIn = this.type === types._in;
      this.next();

      if (
        init.type === "VariableDeclaration" &&
        init.declarations[0].init != null &&
        (
          !isForIn ||
          this.options.ecmaVersion < 8 ||
          this.strict ||
          init.kind !== "var" ||
          init.declarations[0].id.type !== "Identifier"
        )
      ) {
        this.raise(
          init.start,
          ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
        );
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
    };

    // Parse a list of variable declarations.

    pp$1.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) { break }
      }
      return node
    };

    pp$1.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };

    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).

    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
          { this.unexpected(); }
        node.generator = this.eat(types.star);
      }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      if (statement & FUNC_STATEMENT) {
        node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT))
          // If it is a regular function declaration in sloppy mode, then it is
          // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
          // mode depends on properties of the current scope (see
          // treatFunctionsAsVar).
          { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
      }

      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));

      if (!(statement & FUNC_STATEMENT))
        { node.id = this.type === types.name ? this.parseIdent() : null; }

      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
    };

    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };

    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).

    pp$1.parseClass = function(node, isStatement) {
      this.next();

      // ecma-262 14.6 Class Definitions
      // A class definition is always strict mode code.
      var oldStrict = this.strict;
      this.strict = true;

      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
            hadConstructor = true;
          }
        }
      }
      node.body = this.finishNode(classBody, "ClassBody");
      this.strict = oldStrict;
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
    };

    pp$1.parseClassElement = function(constructorAllowsSuper) {
      var this$1 = this;

      if (this.eat(types.semi)) { return null }

      var method = this.startNode();
      var tryContextual = function (k, noLineBreak) {
        if ( noLineBreak === void 0 ) noLineBreak = false;

        var start = this$1.start, startLoc = this$1.startLoc;
        if (!this$1.eatContextual(k)) { return false }
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
        if (method.key) { this$1.unexpected(); }
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false
      };

      method.kind = "method";
      method.static = tryContextual("static");
      var isGenerator = this.eat(types.star);
      var isAsync = false;
      if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) {
          method.kind = "get";
        } else if (tryContextual("set")) {
          method.kind = "set";
        }
      }
      if (!method.key) { this.parsePropertyName(method); }
      var key = method.key;
      var allowsDirectSuper = false;
      if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
          key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
        if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
        if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
      } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && method.value.params.length !== 0)
        { this.raiseRecoverable(method.value.start, "getter should have no params"); }
      if (method.kind === "set" && method.value.params.length !== 1)
        { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
      if (method.kind === "set" && method.value.params[0].type === "RestElement")
        { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
      return method
    };

    pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      return this.finishNode(method, "MethodDefinition")
    };

    pp$1.parseClassId = function(node, isStatement) {
      if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement)
          { this.checkLVal(node.id, BIND_LEXICAL, false); }
      } else {
        if (isStatement === true)
          { this.unexpected(); }
        node.id = null;
      }
    };

    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };

    // Parses module export declaration.

    pp$1.parseExport = function(node, exports) {
      this.next();
      // export * from '...'
      if (this.eat(types.star)) {
        this.expectContextual("from");
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration")
      }
      if (this.eat(types._default)) { // export default ...
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) { this.next(); }
          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration")
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration")
          { this.checkVariableExport(exports, node.declaration.declarations); }
        else
          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
        node.specifiers = [];
        node.source = null;
      } else { // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types.string) { this.unexpected(); }
          node.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            // check for keywords used as local names
            var spec = list[i];

            this.checkUnreserved(spec.local);
            // check if export is defined
            this.checkLocalExport(spec.local);
          }

          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration")
    };

    pp$1.checkExport = function(exports, name, pos) {
      if (!exports) { return }
      if (has(exports, name))
        { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
      exports[name] = true;
    };

    pp$1.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier")
        { this.checkExport(exports, pat.name, pat.start); }
      else if (type === "ObjectPattern")
        { for (var i = 0, list = pat.properties; i < list.length; i += 1)
          {
            var prop = list[i];

            this.checkPatternExport(exports, prop);
          } }
      else if (type === "ArrayPattern")
        { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];

            if (elt) { this.checkPatternExport(exports, elt); }
        } }
      else if (type === "Property")
        { this.checkPatternExport(exports, pat.value); }
      else if (type === "AssignmentPattern")
        { this.checkPatternExport(exports, pat.left); }
      else if (type === "RestElement")
        { this.checkPatternExport(exports, pat.argument); }
      else if (type === "ParenthesizedExpression")
        { this.checkPatternExport(exports, pat.expression); }
    };

    pp$1.checkVariableExport = function(exports, decls) {
      if (!exports) { return }
      for (var i = 0, list = decls; i < list.length; i += 1)
        {
        var decl = list[i];

        this.checkPatternExport(exports, decl.id);
      }
    };

    pp$1.shouldParseExportStatement = function() {
      return this.type.keyword === "var" ||
        this.type.keyword === "const" ||
        this.type.keyword === "class" ||
        this.type.keyword === "function" ||
        this.isLet() ||
        this.isAsyncFunction()
    };

    // Parses a comma-separated list of module exports.

    pp$1.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      // export { x, y as z } [from '...']
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes
    };

    // Parses import declaration.

    pp$1.parseImport = function(node) {
      this.next();
      // import '...'
      if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration")
    };

    // Parses a comma-separated list of module imports.

    pp$1.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) { return nodes }
      }
      if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes
    };

    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$1.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$1.isDirectiveCandidate = function(statement) {
      return (
        statement.type === "ExpressionStatement" &&
        statement.expression.type === "Literal" &&
        typeof statement.expression.value === "string" &&
        // Reject parenthesized strings.
        (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
      )
    };

    var pp$2 = Parser.prototype;

    // Convert existing expression atom to assignable pattern
    // if possible.

    pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await")
            { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
          break

        case "ObjectPattern":
        case "ArrayPattern":
        case "RestElement":
          break

        case "ObjectExpression":
          node.type = "ObjectPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];

          this.toAssignable(prop, isBinding);
            // Early error:
            //   AssignmentRestProperty[Yield, Await] :
            //     `...` DestructuringAssignmentTarget[Yield, Await]
            //
            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
            if (
              prop.type === "RestElement" &&
              (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
            ) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break

        case "Property":
          // AssignmentProperty has type === "Property"
          if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
          this.toAssignable(node.value, isBinding);
          break

        case "ArrayExpression":
          node.type = "ArrayPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          this.toAssignableList(node.elements, isBinding);
          break

        case "SpreadElement":
          node.type = "RestElement";
          this.toAssignable(node.argument, isBinding);
          if (node.argument.type === "AssignmentPattern")
            { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
          break

        case "AssignmentExpression":
          if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isBinding);
          // falls through to AssignmentPattern

        case "AssignmentPattern":
          break

        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          break

        case "MemberExpression":
          if (!isBinding) { break }

        default:
          this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      return node
    };

    // Convert list of expression atoms to binding list.

    pp$2.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) { this.toAssignable(elt, isBinding); }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
          { this.unexpected(last.argument.start); }
      }
      return exprList
    };

    // Parses spread element.

    pp$2.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement")
    };

    pp$2.parseRestBinding = function() {
      var node = this.startNode();
      this.next();

      // RestElement inside of a function parameter must be an identifier
      if (this.options.ecmaVersion === 6 && this.type !== types.name)
        { this.unexpected(); }

      node.argument = this.parseBindingAtom();

      return this.finishNode(node, "RestElement")
    };

    // Parses lvalue (assignable) atom.

    pp$2.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
        case types.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern")

        case types.braceL:
          return this.parseObj(true)
        }
      }
      return this.parseIdent()
    };

    pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) { first = false; }
        else { this.expect(types.comma); }
        if (allowEmpty && this.type === types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break
        } else if (this.type === types.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          this.expect(close);
          break
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts
    };

    pp$2.parseBindingListItem = function(param) {
      return param
    };

    // Parses assignment pattern around given atom if possible.

    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern")
    };

    // Verify that a node is an lval — something that can be assigned
    // to.
    // bindingType can be either:
    // 'var' indicating that the lval creates a 'var' binding
    // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
    // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

    pp$2.checkLVal = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "Identifier":
        if (bindingType === BIND_LEXICAL && expr.name === "let")
          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
        if (checkClashes) {
          if (has(checkClashes, expr.name))
            { this.raiseRecoverable(expr.start, "Argument name clash"); }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
        break

      case "MemberExpression":
        if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
        break

      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1)
          {
        var prop = list[i];

        this.checkLVal(prop, bindingType, checkClashes);
      }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        this.checkLVal(expr.value, bindingType, checkClashes);
        break

      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];

        if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
        }
        break

      case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes);
        break

      case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes);
        break

      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes);
        break

      default:
        this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
      }
    };

    // A recursive descent parser operates by defining functions for all

    var pp$3 = Parser.prototype;

    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.

    pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
        { return }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
        { return }
      var key = prop.key;
      var name;
      switch (key.type) {
      case "Identifier": name = key.name; break
      case "Literal": name = String(key.value); break
      default: return
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
            // Backwards-compat kludge. Can be removed in version 6.0
            else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
          }
          propHash.proto = true;
        }
        return
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition)
          { this.raiseRecoverable(key.start, "Redefinition of property"); }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };

    // ### Expression parsing

    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.

    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).

    pp$3.parseExpression = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
      if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
        return this.finishNode(node, "SequenceExpression")
      }
      return expr
    };

    // Parse an assignment expression. This includes applications of
    // operators like `+=`.

    pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) { return this.parseYield(noIn) }
        // The tokenizer will assume an expression is allowed after
        // `yield`, but this isn't that kind of yield
        else { this.exprAllowed = false; }
      }

      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldShorthandAssign = refDestructuringErrors.shorthandAssign;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }

      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types.parenL || this.type === types.name)
        { this.potentialArrowAt = this.start; }
      var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
      if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
        refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression")
      } else {
        if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
      }
      if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
      if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
      if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
      return left
    };

    // Parse a ternary conditional (`?:`) operator.

    pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression")
      }
      return expr
    };

    // Start the precedence parser.

    pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
    };

    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.

    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND;
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
        }
      }
      return left
    };

    pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
    };

    // Parse unary operators, both prefix and postfix.

    pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
        expr = this.parseAwait();
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) { this.checkLVal(node.argument); }
        else if (this.strict && node.operator === "delete" &&
                 node.argument.type === "Identifier")
          { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
        else { sawUnary = true; }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }

      if (!sawUnary && this.eat(types.starstar))
        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
      else
        { return expr }
    };

    // Parse call, dot, and `[]`-subscript expressions.

    pp$3.parseExprSubscripts = function(refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors);
      var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
      if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
      var result = this.parseSubscripts(expr, startPos, startLoc);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
        if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
      }
      return result
    };

    pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
          this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
        if (element === base || element.type === "ArrowFunctionExpression") { return element }
        base = element;
      }
    };

    pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
      var computed = this.eat(types.bracketL);
      if (computed || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(true);
        node.computed = !!computed;
        if (computed) { this.expect(types.bracketR); }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
        if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0)
            { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (node$1.callee.type === "Import") {
          if (node$1.arguments.length !== 1) {
            this.raise(node$1.start, "import() requires exactly one argument");
          }

          var importArg = node$1.arguments[0];
          if (importArg && importArg.type === "SpreadElement") {
            this.raise(importArg.start, "... is not allowed in import()");
          }
        }
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types.backQuote) {
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({isTagged: true});
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base
    };

    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.

    pp$3.parseExprAtom = function(refDestructuringErrors) {
      // If a division operator appears in an expression position, the
      // tokenizer got confused, and we force it to read a regexp instead.
      if (this.type === types.slash) { this.readRegexp(); }

      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
      case types._super:
        if (!this.allowSuper)
          { this.raise(this.start, "'super' keyword outside a method"); }
        node = this.startNode();
        this.next();
        if (this.type === types.parenL && !this.allowDirectSuper)
          { this.raise(node.start, "super() call outside constructor of a subclass"); }
        // The `super` keyword can appear at below:
        // SuperProperty:
        //     super [ Expression ]
        //     super . IdentifierName
        // SuperCall:
        //     super Arguments
        if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
          { this.unexpected(); }
        return this.finishNode(node, "Super")

      case types._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression")

      case types.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
          { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types.arrow))
              { this.unexpected(); }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
          }
        }
        return id

      case types.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {pattern: value.pattern, flags: value.flags};
        return node

      case types.num: case types.string:
        return this.parseLiteral(this.value)

      case types._null: case types._true: case types._false:
        node = this.startNode();
        node.value = this.type === types._null ? null : this.type === types._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal")

      case types.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            { refDestructuringErrors.parenthesizedAssign = start; }
          if (refDestructuringErrors.parenthesizedBind < 0)
            { refDestructuringErrors.parenthesizedBind = start; }
        }
        return expr

      case types.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression")

      case types.braceL:
        return this.parseObj(false, refDestructuringErrors)

      case types._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, 0)

      case types._class:
        return this.parseClass(this.startNode(), false)

      case types._new:
        return this.parseNew()

      case types.backQuote:
        return this.parseTemplate()

      case types._import:
        if (this.options.ecmaVersion > 10) {
          return this.parseDynamicImport()
        } else {
          return this.unexpected()
        }

      default:
        this.unexpected();
      }
    };

    pp$3.parseDynamicImport = function() {
      var node = this.startNode();
      this.next();
      if (this.type !== types.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Import")
    };

    pp$3.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
      this.next();
      return this.finishNode(node, "Literal")
    };

    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val
    };

    pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();

        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while (this.type !== types.parenR) {
          first ? first = false : this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
            lastIsComma = true;
            break
          } else if (this.type === types.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
            break
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);

        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList)
        }

        if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
        if (spreadStart) { this.unexpected(spreadStart); }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;

        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }

      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression")
      } else {
        return val
      }
    };

    pp$3.parseParenItem = function(item) {
      return item
    };

    pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
    };

    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.

    var empty$1 = [];

    pp$3.parseNew = function() {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target" || containsEsc)
          { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
        if (!this.inNonArrowFunction())
          { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
        return this.finishNode(node, "MetaProperty")
      }
      var startPos = this.start, startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
        this.raise(node.callee.start, "Cannot use new with import(...)");
      }
      if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
      else { node.arguments = empty$1; }
      return this.finishNode(node, "NewExpression")
    };

    // Parse template expression.

    pp$3.parseTemplateElement = function(ref) {
      var isTagged = ref.isTagged;

      var elem = this.startNode();
      if (this.type === types.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types.backQuote;
      return this.finishNode(elem, "TemplateElement")
    };

    pp$3.parseTemplate = function(ref) {
      if ( ref === void 0 ) ref = {};
      var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({isTagged: isTagged});
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral")
    };

    pp$3.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
        (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
        !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    // Parse an object literal or binding pattern.

    pp$3.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
    };

    pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement")
        }
        // To disallow parenthesized identifier via `this.toAssignable()`.
        if (this.type === types.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        // Finish
        return this.finishNode(prop, "SpreadElement")
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern)
          { isGenerator = this.eat(types.star); }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property")
    };

    pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types.colon)
        { this.unexpected(); }

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) { this.unexpected(); }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc &&
                 this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set") &&
                 (this.type !== types.comma && this.type !== types.braceR)) {
        if (isGenerator || isAsync) { this.unexpected(); }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get")
            { this.raiseRecoverable(start, "getter should have no params"); }
          else
            { this.raiseRecoverable(start, "setter should have exactly one param"); }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
            { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = startPos; }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === types.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0)
            { refDestructuringErrors.shorthandAssign = this.start; }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else { this.unexpected(); }
    };

    pp$3.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
          return prop.key
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
    };

    // Initialize empty function node.

    pp$3.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
      if (this.options.ecmaVersion >= 8) { node.async = false; }
    };

    // Parse object or class method.

    pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.initFunction(node);
      if (this.options.ecmaVersion >= 6)
        { node.generator = isGenerator; }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression")
    };

    // Parse arrow function expression with given parameters.

    pp$3.parseArrowExpression = function(node, params, isAsync) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;

      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression")
    };

    // Parse function body and check parameters.

    pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
      var isExpression = isArrowFunction && this.type !== types.braceL;
      var oldStrict = this.strict, useStrict = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          if (useStrict && nonSimple)
            { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) { this.strict = true; }

        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        node.body = this.parseBlock(false);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();

      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      this.strict = oldStrict;
    };

    pp$3.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1)
        {
        var param = list[i];

        if (param.type !== "Identifier") { return false
      } }
      return true
    };

    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.

    pp$3.checkParams = function(node, allowDuplicates) {
      var nameHash = {};
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };

    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).

    pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) { break }
        } else { first = false; }

        var elt = (void 0);
        if (allowEmpty && this.type === types.comma)
          { elt = null; }
        else if (this.type === types.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
            { refDestructuringErrors.trailingComma = this.start; }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts
    };

    pp$3.checkUnreserved = function(ref) {
      var start = ref.start;
      var end = ref.end;
      var name = ref.name;

      if (this.inGenerator && name === "yield")
        { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
      if (this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
      if (this.keywords.test(name))
        { this.raise(start, ("Unexpected keyword '" + name + "'")); }
      if (this.options.ecmaVersion < 6 &&
        this.input.slice(start, end).indexOf("\\") !== -1) { return }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await")
          { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
        this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
      }
    };

    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.

    pp$3.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (liberal && this.options.allowReserved === "never") { liberal = false; }
      if (this.type === types.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;

        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") &&
            (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = node.start; }
      }
      return node
    };

    // Parses yield expression inside generator.

    pp$3.parseYield = function(noIn) {
      if (!this.yieldPos) { this.yieldPos = this.start; }

      var node = this.startNode();
      this.next();
      if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }
      return this.finishNode(node, "YieldExpression")
    };

    pp$3.parseAwait = function() {
      if (!this.awaitPos) { this.awaitPos = this.start; }

      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      return this.finishNode(node, "AwaitExpression")
    };

    var pp$4 = Parser.prototype;

    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.

    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
      throw err
    };

    pp$4.raiseRecoverable = pp$4.raise;

    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart)
      }
    };

    var pp$5 = Parser.prototype;

    var Scope = function Scope(flags) {
      this.flags = flags;
      // A list of var-declared names in the current lexical scope
      this.var = [];
      // A list of lexically-declared names in the current lexical scope
      this.lexical = [];
      // A list of lexically-declared FunctionDeclaration names in the current lexical scope
      this.functions = [];
    };

    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

    pp$5.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };

    pp$5.exitScope = function() {
      this.scopeStack.pop();
    };

    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$5.treatFunctionsAsVarInScope = function(scope) {
      return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
    };

    pp$5.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && (scope.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar)
          { redeclared = scope$2.lexical.indexOf(name) > -1; }
        else
          { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
              !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break
          }
          scope$3.var.push(name);
          if (this.inModule && (scope$3.flags & SCOPE_TOP))
            { delete this.undefinedExports[name]; }
          if (scope$3.flags & SCOPE_VAR) { break }
        }
      }
      if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
    };

    pp$5.checkLocalExport = function(id) {
      // scope.functions must be empty as Module code is always strict.
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
          this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };

    pp$5.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1]
    };

    pp$5.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) { return scope }
      }
    };

    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$5.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
      }
    };

    var Node$1 = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations)
        { this.loc = new SourceLocation(parser, loc); }
      if (parser.options.directSourceFile)
        { this.sourceFile = parser.options.directSourceFile; }
      if (parser.options.ranges)
        { this.range = [pos, 0]; }
    };

    // Start an AST node, attaching a start offset.

    var pp$6 = Parser.prototype;

    pp$6.startNode = function() {
      return new Node$1(this, this.start, this.startLoc)
    };

    pp$6.startNodeAt = function(pos, loc) {
      return new Node$1(this, pos, loc)
    };

    // Finish an AST node, adding `type` and `end` properties.

    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations)
        { node.loc.end = loc; }
      if (this.options.ranges)
        { node.range[1] = pos; }
      return node
    }

    pp$6.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
    };

    // Finish node at given position

    pp$6.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc)
    };

    // The algorithm used to determine whether a regexp can appear at a

    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };

    var types$1 = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };

    var pp$7 = Parser.prototype;

    pp$7.initialContext = function() {
      return [types$1.b_stat]
    };

    pp$7.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$1.f_expr || parent === types$1.f_stat)
        { return true }
      if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
        { return !parent.isExpr }

      // The check for `tt.name && exprAllowed` detects whether we are
      // after a `yield` or `of` construct. See the `updateContext` for
      // `tt.name`.
      if (prevType === types._return || prevType === types.name && this.exprAllowed)
        { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
        { return true }
      if (prevType === types.braceL)
        { return parent === types$1.b_stat }
      if (prevType === types._var || prevType === types._const || prevType === types.name)
        { return false }
      return !this.exprAllowed
    };

    pp$7.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function")
          { return context.generator }
      }
      return false
    };

    pp$7.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types.dot)
        { this.exprAllowed = false; }
      else if (update = type.updateContext)
        { update.call(this, prevType); }
      else
        { this.exprAllowed = type.beforeExpr; }
    };

    // Token-specific context update code

    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return
      }
      var out = this.context.pop();
      if (out === types$1.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };

    types.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
      this.exprAllowed = true;
    };

    types.dollarBraceL.updateContext = function() {
      this.context.push(types$1.b_tmpl);
      this.exprAllowed = true;
    };

    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
      this.exprAllowed = true;
    };

    types.incDec.updateContext = function() {
      // tokExprAllowed stays unchanged
    };

    types._function.updateContext = types._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
          !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
          !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
        { this.context.push(types$1.f_expr); }
      else
        { this.context.push(types$1.f_stat); }
      this.exprAllowed = false;
    };

    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.q_tmpl)
        { this.context.pop(); }
      else
        { this.context.push(types$1.q_tmpl); }
      this.exprAllowed = false;
    };

    types.star.updateContext = function(prevType) {
      if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr)
          { this.context[index] = types$1.f_expr_gen; }
        else
          { this.context[index] = types$1.f_gen; }
      }
      this.exprAllowed = true;
    };

    types.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed ||
            this.value === "yield" && this.inGeneratorContext())
          { allowed = true; }
      }
      this.exprAllowed = allowed;
    };

    // This file contains Unicode properties extracted from the ECMAScript
    // specification. The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties
    };

    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues
    };

    var data = {};
    function buildUnicodeData(ecmaVersion) {
      var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
      };
      d.nonBinary.Script_Extensions = d.nonBinary.Script;

      d.nonBinary.gc = d.nonBinary.General_Category;
      d.nonBinary.sc = d.nonBinary.Script;
      d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    buildUnicodeData(9);
    buildUnicodeData(10);
    buildUnicodeData(11);

    var pp$8 = Parser.prototype;

    var RegExpValidationState = function RegExpValidationState(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };

    RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };

    RegExpValidationState.prototype.raise = function raise (message) {
      this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
    };

    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at (i) {
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1
      }
      var c = s.charCodeAt(i);
      if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return c
      }
      return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
    };

    RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l
      }
      var c = s.charCodeAt(i);
      if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return i + 1
      }
      return i + 2
    };

    RegExpValidationState.prototype.current = function current () {
      return this.at(this.pos)
    };

    RegExpValidationState.prototype.lookahead = function lookahead () {
      return this.at(this.nextIndex(this.pos))
    };

    RegExpValidationState.prototype.advance = function advance () {
      this.pos = this.nextIndex(this.pos);
    };

    RegExpValidationState.prototype.eat = function eat (ch) {
      if (this.current() === ch) {
        this.advance();
        return true
      }
      return false
    };

    function codePointToString(ch) {
      if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
      ch -= 0x10000;
      return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
    }

    /**
     * Validate the flags part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$8.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;

      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };

    /**
     * Validate the pattern part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$8.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);

      // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
      // parsing contains a |GroupName|, reparse with the goal symbol
      // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
      // exception if _P_ did not conform to the grammar, if any elements of _P_
      // were not matched by the parse, or if any Early Error conditions exist.
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$8.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;

      this.regexp_disjunction(state);

      if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(0x29 /* ) */)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];

        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$8.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(0x7C /* | */)) {
        this.regexp_alternative(state);
      }

      // Make the same message as V8.
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(0x7B /* { */)) {
        state.raise("Lone quantifier brackets");
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$8.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state))
        { }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$8.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          // Make the same message as V8.
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true
      }

      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$8.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;

      // ^, $
      if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
        return true
      }

      // \b \B
      if (state.eat(0x5C /* \ */)) {
        if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
          return true
        }
        state.pos = start;
      }

      // Lookahead / Lookbehind
      if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(0x3C /* < */);
        }
        if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
          this.regexp_disjunction(state);
          if (!state.eat(0x29 /* ) */)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true
        }
      }

      state.pos = start;
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$8.regexp_eatQuantifier = function(state, noError) {
      if ( noError === void 0 ) noError = false;

      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(0x3F /* ? */);
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
      return (
        state.eat(0x2A /* * */) ||
        state.eat(0x2B /* + */) ||
        state.eat(0x3F /* ? */) ||
        this.regexp_eatBracedQuantifier(state, noError)
      )
    };
    pp$8.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(0x7B /* { */)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(0x7D /* } */)) {
            // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$8.regexp_eatAtom = function(state) {
      return (
        this.regexp_eatPatternCharacters(state) ||
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state)
      )
    };
    pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(0x28 /* ( */)) {
        if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
          this.regexp_disjunction(state);
          if (state.eat(0x29 /* ) */)) {
            return true
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatCapturingGroup = function(state) {
      if (state.eat(0x28 /* ( */)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 0x3F /* ? */) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          state.numCapturingParens += 1;
          return true
        }
        state.raise("Unterminated group");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$8.regexp_eatExtendedAtom = function(state) {
      return (
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state) ||
        this.regexp_eatInvalidBracedQuantifier(state) ||
        this.regexp_eatExtendedPatternCharacter(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$8.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };
    function isSyntaxCharacter(ch) {
      return (
        ch === 0x24 /* $ */ ||
        ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
        ch === 0x2E /* . */ ||
        ch === 0x3F /* ? */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$8.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$8.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (
        ch !== -1 &&
        ch !== 0x24 /* $ */ &&
        !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
        ch !== 0x2E /* . */ &&
        ch !== 0x3F /* ? */ &&
        ch !== 0x5B /* [ */ &&
        ch !== 0x5E /* ^ */ &&
        ch !== 0x7C /* | */
      ) {
        state.advance();
        return true
      }
      return false
    };

    // GroupSpecifier[U] ::
    //   [empty]
    //   `?` GroupName[?U]
    pp$8.regexp_groupSpecifier = function(state) {
      if (state.eat(0x3F /* ? */)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return
        }
        state.raise("Invalid group");
      }
    };

    // GroupName[U] ::
    //   `<` RegExpIdentifierName[?U] `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$8.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(0x3C /* < */)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
          return true
        }
        state.raise("Invalid capture group name");
      }
      return false
    };

    // RegExpIdentifierName[U] ::
    //   RegExpIdentifierStart[?U]
    //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$8.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true
      }
      return false
    };

    // RegExpIdentifierStart[U] ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[?U]
    pp$8.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var ch = state.current();
      state.advance();

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierStart(ch) {
      return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
    }

    // RegExpIdentifierPart[U] ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[?U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$8.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var ch = state.current();
      state.advance();

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierPart(ch) {
      return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$8.regexp_eatAtomEscape = function(state) {
      if (
        this.regexp_eatBackReference(state) ||
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state) ||
        (state.switchN && this.regexp_eatKGroupName(state))
      ) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 0x63 /* c */) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false
    };
    pp$8.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true
        }
        if (n <= state.numCapturingParens) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatKGroupName = function(state) {
      if (state.eat(0x6B /* k */)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true
        }
        state.raise("Invalid named reference");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$8.regexp_eatCharacterEscape = function(state) {
      return (
        this.regexp_eatControlEscape(state) ||
        this.regexp_eatCControlLetter(state) ||
        this.regexp_eatZero(state) ||
        this.regexp_eatHexEscapeSequence(state) ||
        this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
        (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
        this.regexp_eatIdentityEscape(state)
      )
    };
    pp$8.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(0x63 /* c */)) {
        if (this.regexp_eatControlLetter(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatZero = function(state) {
      if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$8.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 0x74 /* t */) {
        state.lastIntValue = 0x09; /* \t */
        state.advance();
        return true
      }
      if (ch === 0x6E /* n */) {
        state.lastIntValue = 0x0A; /* \n */
        state.advance();
        return true
      }
      if (ch === 0x76 /* v */) {
        state.lastIntValue = 0x0B; /* \v */
        state.advance();
        return true
      }
      if (ch === 0x66 /* f */) {
        state.lastIntValue = 0x0C; /* \f */
        state.advance();
        return true
      }
      if (ch === 0x72 /* r */) {
        state.lastIntValue = 0x0D; /* \r */
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$8.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };
    function isControlLetter(ch) {
      return (
        (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
        (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
      var start = state.pos;

      if (state.eat(0x75 /* u */)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 0xDC00 && trail <= 0xDFFF) {
                state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                return true
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true
        }
        if (
          state.switchU &&
          state.eat(0x7B /* { */) &&
          this.regexp_eatHexDigits(state) &&
          state.eat(0x7D /* } */) &&
          isValidUnicode(state.lastIntValue)
        ) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }

      return false
    };
    function isValidUnicode(ch) {
      return ch >= 0 && ch <= 0x10FFFF
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$8.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true
        }
        if (state.eat(0x2F /* / */)) {
          state.lastIntValue = 0x2F; /* / */
          return true
        }
        return false
      }

      var ch = state.current();
      if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$8.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
          state.advance();
        } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$8.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();

      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true
      }

      if (
        state.switchU &&
        this.options.ecmaVersion >= 9 &&
        (ch === 0x50 /* P */ || ch === 0x70 /* p */)
      ) {
        state.lastIntValue = -1;
        state.advance();
        if (
          state.eat(0x7B /* { */) &&
          this.regexp_eatUnicodePropertyValueExpression(state) &&
          state.eat(0x7D /* } */)
        ) {
          return true
        }
        state.raise("Invalid property name");
      }

      return false
    };
    function isCharacterClassEscape(ch) {
      return (
        ch === 0x64 /* d */ ||
        ch === 0x44 /* D */ ||
        ch === 0x73 /* s */ ||
        ch === 0x53 /* S */ ||
        ch === 0x77 /* w */ ||
        ch === 0x57 /* W */
      )
    }

    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;

      // UnicodePropertyName `=` UnicodePropertyValue
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true
        }
      }
      state.pos = start;

      // LoneUnicodePropertyNameOrValue
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true
      }
      return false
    };
    pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!has(state.unicodeProperties.nonBinary, name))
        { state.raise("Invalid property name"); }
      if (!state.unicodeProperties.nonBinary[name].test(value))
        { state.raise("Invalid property value"); }
    };
    pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue))
        { state.raise("Invalid property name"); }
    };

    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$8.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyNameCharacter(ch) {
      return isControlLetter(ch) || ch === 0x5F /* _ */
    }

    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$8.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyValueCharacter(ch) {
      return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
    }

    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state)
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$8.regexp_eatCharacterClass = function(state) {
      if (state.eat(0x5B /* [ */)) {
        state.eat(0x5E /* ^ */);
        this.regexp_classRanges(state);
        if (state.eat(0x5D /* [ */)) {
          return true
        }
        // Unreachable since it threw "unterminated regular expression" error before.
        state.raise("Unterminated character class");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$8.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$8.regexp_eatClassAtom = function(state) {
      var start = state.pos;

      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatClassEscape(state)) {
          return true
        }
        if (state.switchU) {
          // Make the same message as V8.
          var ch$1 = state.current();
          if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }

      var ch = state.current();
      if (ch !== 0x5D /* [ */) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$8.regexp_eatClassEscape = function(state) {
      var start = state.pos;

      if (state.eat(0x62 /* b */)) {
        state.lastIntValue = 0x08; /* <BS> */
        return true
      }

      if (state.switchU && state.eat(0x2D /* - */)) {
        state.lastIntValue = 0x2D; /* - */
        return true
      }

      if (!state.switchU && state.eat(0x63 /* c */)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true
        }
        state.pos = start;
      }

      return (
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$8.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$8.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(0x78 /* x */)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$8.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      }
      return state.pos !== start
    };
    function isDecimalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$8.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start
    };
    function isHexDigit(ch) {
      return (
        (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
        (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
        (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
      )
    }
    function hexToInt(ch) {
      if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
        return 10 + (ch - 0x41 /* A */)
      }
      if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
        return 10 + (ch - 0x61 /* a */)
      }
      return ch - 0x30 /* 0 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$8.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 0x30; /* 0 */
        state.advance();
        return true
      }
      state.lastIntValue = 0;
      return false
    };
    function isOctalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$8.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true
    };

    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.

    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations)
        { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
      if (p.options.ranges)
        { this.range = [p.start, p.end]; }
    };

    // ## Tokenizer

    var pp$9 = Parser.prototype;

    // Move to the next token

    pp$9.next = function() {
      if (this.options.onToken)
        { this.options.onToken(new Token(this)); }

      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };

    pp$9.getToken = function() {
      this.next();
      return new Token(this)
    };

    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined")
      { pp$9[Symbol.iterator] = function() {
        var this$1 = this;

        return {
          next: function () {
            var token = this$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            }
          }
        }
      }; }

    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).

    pp$9.curContext = function() {
      return this.context[this.context.length - 1]
    };

    // Read a single token, updating the parser object's token-related
    // properties.

    pp$9.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

      this.start = this.pos;
      if (this.options.locations) { this.startLoc = this.curPosition(); }
      if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

      if (curContext.override) { return curContext.override(this) }
      else { this.readToken(this.fullCharCodeAtPos()); }
    };

    pp$9.readToken = function(code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
        { return this.readWord() }

      return this.getTokenFromCode(code)
    };

    pp$9.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xe000) { return code }
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 0x35fdc00
    };

    pp$9.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment)
        { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    pp$9.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment)
        { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.

    pp$9.skipSpace = function() {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
        case 32: case 160: // ' '
          ++this.pos;
          break
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10: case 8232: case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break
        case 47: // '/'
          switch (this.input.charCodeAt(this.pos + 1)) {
          case 42: // '*'
            this.skipBlockComment();
            break
          case 47:
            this.skipLineComment(2);
            break
          default:
            break loop
          }
          break
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop
          }
        }
      }
    };

    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.

    pp$9.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) { this.endLoc = this.curPosition(); }
      var prevType = this.type;
      this.type = type;
      this.value = val;

      this.updateContext(prevType);
    };

    // ### Token reading

    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp$9.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) { return this.readNumber(true) }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(types.ellipsis)
      } else {
        ++this.pos;
        return this.finishToken(types.dot)
      }
    };

    pp$9.readToken_slash = function() { // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.slash, 1)
    };

    pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types.star : types.modulo;

      // exponentiation operator ** and **=
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }

      if (next === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(tokentype, size)
    };

    pp$9.readToken_pipe_amp = function(code) { // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
    };

    pp$9.readToken_caret = function() { // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.bitwiseXOR, 1)
    };

    pp$9.readToken_plus_min = function(code) { // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
            (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken()
        }
        return this.finishOp(types.incDec, 2)
      }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.plusMin, 1)
    };

    pp$9.readToken_lt_gt = function(code) { // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
        return this.finishOp(types.bitShift, size)
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
          this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken()
      }
      if (next === 61) { size = 2; }
      return this.finishOp(types.relational, size)
    };

    pp$9.readToken_eq_excl = function(code) { // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
        this.pos += 2;
        return this.finishToken(types.arrow)
      }
      return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
    };

    pp$9.getTokenFromCode = function(code) {
      switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46: // '.'
        return this.readToken_dot()

      // Punctuation tokens.
      case 40: ++this.pos; return this.finishToken(types.parenL)
      case 41: ++this.pos; return this.finishToken(types.parenR)
      case 59: ++this.pos; return this.finishToken(types.semi)
      case 44: ++this.pos; return this.finishToken(types.comma)
      case 91: ++this.pos; return this.finishToken(types.bracketL)
      case 93: ++this.pos; return this.finishToken(types.bracketR)
      case 123: ++this.pos; return this.finishToken(types.braceL)
      case 125: ++this.pos; return this.finishToken(types.braceR)
      case 58: ++this.pos; return this.finishToken(types.colon)
      case 63: ++this.pos; return this.finishToken(types.question)

      case 96: // '`'
        if (this.options.ecmaVersion < 6) { break }
        ++this.pos;
        return this.finishToken(types.backQuote)

      case 48: // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
          if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
        }

      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
        return this.readNumber(false)

      // Quotes produce strings.
      case 34: case 39: // '"', "'"
        return this.readString(code)

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47: // '/'
        return this.readToken_slash()

      case 37: case 42: // '%*'
        return this.readToken_mult_modulo_exp(code)

      case 124: case 38: // '|&'
        return this.readToken_pipe_amp(code)

      case 94: // '^'
        return this.readToken_caret()

      case 43: case 45: // '+-'
        return this.readToken_plus_min(code)

      case 60: case 62: // '<>'
        return this.readToken_lt_gt(code)

      case 61: case 33: // '=!'
        return this.readToken_eq_excl(code)

      case 126: // '~'
        return this.finishOp(types.prefix, 1)
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
    };

    pp$9.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str)
    };

    pp$9.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
        if (!escaped) {
          if (ch === "[") { inClass = true; }
          else if (ch === "]" && inClass) { inClass = false; }
          else if (ch === "/" && !inClass) { break }
          escaped = ch === "\\";
        } else { escaped = false; }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) { this.unexpected(flagsStart); }

      // Validate pattern
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);

      // Create Literal#value property value.
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
      }

      return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
    };

    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.

    pp$9.readInt = function(radix, len) {
      var start = this.pos, total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.pos), val = (void 0);
        if (code >= 97) { val = code - 97 + 10; } // a
        else if (code >= 65) { val = code - 65 + 10; } // A
        else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
        else { val = Infinity; }
        if (val >= radix) { break }
        ++this.pos;
        total = total * radix + val;
      }
      if (this.pos === start || len != null && this.pos - start !== len) { return null }

      return total
    };

    pp$9.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val)
    };

    // Read an integer, octal integer, or floating-point number.

    pp$9.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) { this.raise(start, "Invalid number"); }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var str$1 = this.input.slice(start, this.pos);
        var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
        return this.finishToken(types.num, val$1)
      }
      if (next === 46 && !octal) { // '.'
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) { // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) { ++this.pos; } // '+-'
        if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

      var str = this.input.slice(start, this.pos);
      var val = octal ? parseInt(str, 8) : parseFloat(str);
      return this.finishToken(types.num, val)
    };

    // Read a string value, interpreting backslash-escapes.

    pp$9.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;

      if (ch === 123) { // '{'
        if (this.options.ecmaVersion < 6) { this.unexpected(); }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
      } else {
        code = this.readHexChar(4);
      }
      return code
    };

    function codePointToString$1(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) { return String.fromCharCode(code) }
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
    }

    pp$9.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) { break }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else {
          if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types.string, out)
    };

    // Reads template string tokens.

    var INVALID_TEMPLATE_ESCAPE_ERROR = {};

    pp$9.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err
        }
      }

      this.inTemplateElement = false;
    };

    pp$9.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR
      } else {
        this.raise(position, message);
      }
    };

    pp$9.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
          if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types.dollarBraceL)
            } else {
              ++this.pos;
              return this.finishToken(types.backQuote)
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types.template, out)
        }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
          case 10:
            out += "\n";
            break
          default:
            out += String.fromCharCode(ch);
            break
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };

    // Reads a template token to search for the end, without validating any escape sequences
    pp$9.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break

        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break
          }
        // falls through

        case "`":
          return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

        // no default
        }
      }
      this.raise(this.start, "Unterminated template");
    };

    // Used to read escaped characters

    pp$9.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
      case 110: return "\n" // 'n' -> '\n'
      case 114: return "\r" // 'r' -> '\r'
      case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
      case 117: return codePointToString$1(this.readCodePoint()) // 'u'
      case 116: return "\t" // 't' -> '\t'
      case 98: return "\b" // 'b' -> '\b'
      case 118: return "\u000b" // 'v' -> '\u000b'
      case 102: return "\f" // 'f' -> '\f'
      case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
      case 10: // ' \n'
        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
        return ""
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(
              this.pos - 1 - octalStr.length,
              inTemplate
                ? "Octal literal in template string"
                : "Octal literal in strict mode"
            );
          }
          return String.fromCharCode(octal)
        }
        if (isNewLine(ch)) {
          // Unicode new line characters after \ get removed from output in both
          // template literals and strings
          return ""
        }
        return String.fromCharCode(ch)
      }
    };

    // Used to read character escape sequences ('\x', '\u', '\U').

    pp$9.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
      return n
    };

    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.

    pp$9.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) { // "\"
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) // "u"
            { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
            { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
          word += codePointToString$1(esc);
          chunkStart = this.pos;
        } else {
          break
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos)
    };

    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.

    pp$9.readWord = function() {
      var word = this.readWord1();
      var type = types.name;
      if (this.keywords.test(word)) {
        if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
        type = keywords$1[word];
      }
      return this.finishToken(type, word)
    };

    // Acorn is a tiny, fast JavaScript parser written in JavaScript.

    var version = "6.2.1";

    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

    function parse(input, options) {
      return Parser.parse(input, options)
    }

    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.

    function parseExpressionAt(input, pos, options) {
      return Parser.parseExpressionAt(input, pos, options)
    }

    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenizer` export provides an interface to the tokenizer.

    function tokenizer(input, options) {
      return Parser.tokenizer(input, options)
    }

    var acorn = /*#__PURE__*/Object.freeze({
        Node: Node$1,
        Parser: Parser,
        Position: Position,
        SourceLocation: SourceLocation,
        TokContext: TokContext,
        Token: Token,
        TokenType: TokenType,
        defaultOptions: defaultOptions,
        getLineInfo: getLineInfo,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        isNewLine: isNewLine,
        keywordTypes: keywords$1,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace,
        parse: parse,
        parseExpressionAt: parseExpressionAt,
        tokContexts: types$1,
        tokTypes: types,
        tokenizer: tokenizer,
        version: version
    });

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var acorn$1 = getCjsExportFromNamespace(acorn);

    const tt = acorn$1.tokTypes;
    const isIdentifierStart$1 = acorn$1.isIdentifierStart;

    var acornBigint = function(Parser) {
      return class extends Parser {
        parseLiteral(value) {
          const node = super.parseLiteral(value);
          if (node.raw.charCodeAt(node.raw.length - 1) == 110) node.bigint = node.raw;
          return node
        }

        readRadixNumber(radix) {
          let start = this.pos;
          this.pos += 2; // 0x
          let val = this.readInt(radix);
          if (val === null) this.raise(this.start + 2, `Expected number in radix ${radix}`);
          if (this.input.charCodeAt(this.pos) == 110) {
            let str = this.input.slice(start, this.pos);
            val = typeof BigInt !== "undefined" ? BigInt(str) : null;
            ++this.pos;
          } else if (isIdentifierStart$1(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
          return this.finishToken(tt.num, val)
        }

        readNumber(startsWithDot) {
          let start = this.pos;

          // Not an int
          if (startsWithDot) return super.readNumber(startsWithDot)

          // Legacy octal
          if (this.input.charCodeAt(start) === 48 && this.input.charCodeAt(start + 1) !== 110) {
            return super.readNumber(startsWithDot)
          }

          if (this.readInt(10) === null) this.raise(start, "Invalid number");

          // Not a BigInt, reset and parse again
          if (this.input.charCodeAt(this.pos) != 110) {
            this.pos = start;
            return super.readNumber(startsWithDot)
          }

          let str = this.input.slice(start, this.pos);
          let val = typeof BigInt !== "undefined" ? BigInt(str) : null;
          ++this.pos;
          return this.finishToken(tt.num, val)
        }
      }
    };

    // A more accurate version of acorn-dynamic-import.

    // NOTE: This allows `yield import()` to parse correctly.
    types._import.startsExpr = true;

    function parseImportCall(parser) {
      const node = parser.startNode();
      const {start} = parser;
      const callExpr = parser.startNode();
      const callee = parser.parseExprAtom();
      parser.expect(types.parenL);
      callExpr.arguments = [parser.parseMaybeAssign()];
      callExpr.callee = callee;
      parser.finishNode(callExpr, "CallExpression");
      parser.expect(types.parenR);
      const expr = parser.parseSubscripts(callExpr, start);
      return parser.parseExpressionStatement(node, expr);
    }

    function parseImportCallAtom(parser) {
      const node = parser.startNode();
      parser.expect(types._import);
      return parser.finishNode(node, "Import");
    }

    function dynamicImport(Parser) {
      const parser = new Parser();

      function lookahead({input, pos}) {
        parser.input = input;
        parser.pos = pos;
        parser.nextToken();
        return parser;
      }

      return class extends Parser {
        parseExprAtom(...args) {
          if (this.type === types._import) {
            const {type} = lookahead(this);
            if (type === types.parenL) return parseImportCallAtom(this);
            this.unexpected();
          }
          return super.parseExprAtom(...args);
        }
        parseStatement(...args) {
          if (this.type === types._import) {
            const {type} = lookahead(this);
            if (type === types.parenL) return parseImportCall(this);
          }
          return super.parseStatement(...args);
        }
      };
    }

    var defaultGlobals = new Set([
      "Array",
      "ArrayBuffer",
      "atob",
      "AudioContext",
      "Blob",
      "Boolean",
      "BigInt",
      "btoa",
      "clearInterval",
      "clearTimeout",
      "console",
      "crypto",
      "CustomEvent",
      "DataView",
      "Date",
      "decodeURI",
      "decodeURIComponent",
      "devicePixelRatio",
      "document",
      "encodeURI",
      "encodeURIComponent",
      "Error",
      "escape",
      "eval",
      "fetch",
      "File",
      "FileList",
      "FileReader",
      "Float32Array",
      "Float64Array",
      "Function",
      "Headers",
      "Image",
      "ImageData",
      "Infinity",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Intl",
      "isFinite",
      "isNaN",
      "JSON",
      "Map",
      "Math",
      "NaN",
      "Number",
      "navigator",
      "Object",
      "parseFloat",
      "parseInt",
      "performance",
      "Path2D",
      "Promise",
      "Proxy",
      "RangeError",
      "ReferenceError",
      "Reflect",
      "RegExp",
      "cancelAnimationFrame",
      "requestAnimationFrame",
      "Set",
      "setInterval",
      "setTimeout",
      "String",
      "Symbol",
      "SyntaxError",
      "TextDecoder",
      "TextEncoder",
      "this",
      "TypeError",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "undefined",
      "unescape",
      "URIError",
      "URL",
      "WeakMap",
      "WeakSet",
      "WebSocket",
      "Worker",
      "window"
    ]);

    // AST walker module for Mozilla Parser API compatible trees

    // An ancestor walk keeps an array of ancestor nodes (including the
    // current node) and passes them to the callback as third parameter
    // (and also as state parameter when no other state is present).
    function ancestor(node, visitors, baseVisitor, state) {
      var ancestors = [];
      if (!baseVisitor) { baseVisitor = base
      ; }(function c(node, st, override) {
        var type = override || node.type, found = visitors[type];
        var isNew = node !== ancestors[ancestors.length - 1];
        if (isNew) { ancestors.push(node); }
        baseVisitor[type](node, st, c);
        if (found) { found(node, st || ancestors, ancestors); }
        if (isNew) { ancestors.pop(); }
      })(node, state);
    }

    // Fallback to an Object.create polyfill for older environments.
    var create = Object.create || function(proto) {
      function Ctor() {}
      Ctor.prototype = proto;
      return new Ctor
    };

    // Used to create a custom walker. Will fill in all missing node
    // type properties with the defaults.
    function make(funcs, baseVisitor) {
      var visitor = create(baseVisitor || base);
      for (var type in funcs) { visitor[type] = funcs[type]; }
      return visitor
    }

    function skipThrough(node, st, c) { c(node, st); }
    function ignore(_node, _st, _c) {}

    // Node walkers.

    var base = {};

    base.Program = base.BlockStatement = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var stmt = list[i];

        c(stmt, st, "Statement");
      }
    };
    base.Statement = skipThrough;
    base.EmptyStatement = ignore;
    base.ExpressionStatement = base.ParenthesizedExpression =
      function (node, st, c) { return c(node.expression, st, "Expression"); };
    base.IfStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) { c(node.alternate, st, "Statement"); }
    };
    base.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
    base.BreakStatement = base.ContinueStatement = ignore;
    base.WithStatement = function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.SwitchStatement = function (node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];

        if (cs.test) { c(cs.test, st, "Expression"); }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1)
          {
          var cons = list[i];

          c(cons, st, "Statement");
        }
      }
    };
    base.SwitchCase = function (node, st, c) {
      if (node.test) { c(node.test, st, "Expression"); }
      for (var i = 0, list = node.consequent; i < list.length; i += 1)
        {
        var cons = list[i];

        c(cons, st, "Statement");
      }
    };
    base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
      if (node.argument) { c(node.argument, st, "Expression"); }
    };
    base.ThrowStatement = base.SpreadElement =
      function (node, st, c) { return c(node.argument, st, "Expression"); };
    base.TryStatement = function (node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) { c(node.handler, st); }
      if (node.finalizer) { c(node.finalizer, st, "Statement"); }
    };
    base.CatchClause = function (node, st, c) {
      if (node.param) { c(node.param, st, "Pattern"); }
      c(node.body, st, "Statement");
    };
    base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForStatement = function (node, st, c) {
      if (node.init) { c(node.init, st, "ForInit"); }
      if (node.test) { c(node.test, st, "Expression"); }
      if (node.update) { c(node.update, st, "Expression"); }
      c(node.body, st, "Statement");
    };
    base.ForInStatement = base.ForOfStatement = function (node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForInit = function (node, st, c) {
      if (node.type === "VariableDeclaration") { c(node, st); }
      else { c(node, st, "Expression"); }
    };
    base.DebuggerStatement = ignore;

    base.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
    base.VariableDeclaration = function (node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1)
        {
        var decl = list[i];

        c(decl, st);
      }
    };
    base.VariableDeclarator = function (node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) { c(node.init, st, "Expression"); }
    };

    base.Function = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };

    base.Pattern = function (node, st, c) {
      if (node.type === "Identifier")
        { c(node, st, "VariablePattern"); }
      else if (node.type === "MemberExpression")
        { c(node, st, "MemberPattern"); }
      else
        { c(node, st); }
    };
    base.VariablePattern = ignore;
    base.MemberPattern = skipThrough;
    base.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
    base.ArrayPattern = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Pattern"); }
      }
    };
    base.ObjectPattern = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

        if (prop.type === "Property") {
          if (prop.computed) { c(prop.key, st, "Expression"); }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };

    base.Expression = skipThrough;
    base.ThisExpression = base.Super = base.MetaProperty = ignore;
    base.ArrayExpression = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Expression"); }
      }
    };
    base.ObjectExpression = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1)
        {
        var prop = list[i];

        c(prop, st);
      }
    };
    base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
    base.SequenceExpression = function (node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1)
        {
        var expr = list[i];

        c(expr, st, "Expression");
      }
    };
    base.TemplateLiteral = function (node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1)
        {
        var quasi = list[i];

        c(quasi, st);
      }

      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
        {
        var expr = list$1[i$1];

        c(expr, st, "Expression");
      }
    };
    base.TemplateElement = ignore;
    base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
      c(node.argument, st, "Expression");
    };
    base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base.ConditionalExpression = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base.NewExpression = base.CallExpression = function (node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments)
        { for (var i = 0, list = node.arguments; i < list.length; i += 1)
          {
            var arg = list[i];

            c(arg, st, "Expression");
          } }
    };
    base.MemberExpression = function (node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) { c(node.property, st, "Expression"); }
    };
    base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
      if (node.declaration)
        { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
      if (node.source) { c(node.source, st, "Expression"); }
    };
    base.ExportAllDeclaration = function (node, st, c) {
      c(node.source, st, "Expression");
    };
    base.ImportDeclaration = function (node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1)
        {
        var spec = list[i];

        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;

    base.TaggedTemplateExpression = function (node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
    base.Class = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      if (node.superClass) { c(node.superClass, st, "Expression"); }
      c(node.body, st);
    };
    base.ClassBody = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var elt = list[i];

        c(elt, st);
      }
    };
    base.MethodDefinition = base.Property = function (node, st, c) {
      if (node.computed) { c(node.key, st, "Expression"); }
      c(node.value, st, "Expression");
    };

    var walk = make({
      Import() {},
      SpreadProperty(node, st, c) {
        c(node.argument, st, "Expression");
      },
      ObjectPattern(node, st, c) {
        const list = node.properties;
        for (const prop of list) {
          c(prop.value || prop.argument, st, "Pattern");
        }
      },
      ViewExpression(node, st, c) {
        c(node.id, st, "Identifier");
      },
      MutableExpression(node, st, c) {
        c(node.id, st, "Identifier");
      }
    });

    // Base on https://github.com/ForbesLindesay/acorn-globals

    function isScope(node) {
      return node.type === "FunctionExpression"
          || node.type === "FunctionDeclaration"
          || node.type === "ArrowFunctionExpression"
          || node.type === "Program";
    }

    function isBlockScope(node) {
      return node.type === "BlockStatement"
          || node.type === "ForInStatement"
          || node.type === "ForOfStatement"
          || node.type === "ForStatement"
          || isScope(node);
    }

    function declaresArguments(node) {
      return node.type === "FunctionExpression"
          || node.type === "FunctionDeclaration";
    }

    function findReferences(cell, globals) {
      const ast = {type: "Program", body: [cell.body]};
      const locals = new Map;
      const referenceSet = new Set(globals);
      const references = [];

      function hasLocal(node, name) {
        const l = locals.get(node);
        return l ? l.has(name) : false;
      }

      function declareLocal(node, id) {
        const l = locals.get(node);
        if (l) l.add(id.name);
        else locals.set(node, new Set([id.name]));
      }

      function declareClass(node) {
        if (node.id) declareLocal(node, node.id);
      }

      function declareFunction(node) {
        node.params.forEach(param => declarePattern(param, node));
        if (node.id) declareLocal(node, node.id);
      }

      function declareCatchClause(node) {
        if (node.param) declarePattern(node.param, node);
      }

      function declarePattern(node, parent) {
        switch (node.type) {
          case "Identifier":
            declareLocal(parent, node);
            break;
          case "ObjectPattern":
            node.properties.forEach(node => declarePattern(node, parent));
            break;
          case "ArrayPattern":
            node.elements.forEach(node => node && declarePattern(node, parent));
            break;
          case "Property":
            declarePattern(node.value, parent);
            break;
          case "RestElement":
            declarePattern(node.argument, parent);
            break;
          case "AssignmentPattern":
            declarePattern(node.left, parent);
            break;
          default:
            throw new Error("Unrecognized pattern type: " + node.type);
        }
      }

      function declareModuleSpecifier(node) {
        declareLocal(ast, node.local);
      }

      ancestor(
        ast,
        {
          VariableDeclaration: (node, parents) => {
            let parent = null;
            for (let i = parents.length - 1; i >= 0 && parent === null; --i) {
              if (node.kind === "var" ? isScope(parents[i]) : isBlockScope(parents[i])) {
                parent = parents[i];
              }
            }
            node.declarations.forEach(declaration => declarePattern(declaration.id, parent));
          },
          FunctionDeclaration: (node, parents) => {
            let parent = null;
            for (let i = parents.length - 2; i >= 0 && parent === null; --i) {
              if (isScope(parents[i])) {
                parent = parents[i];
              }
            }
            declareLocal(parent, node.id);
            declareFunction(node);
          },
          Function: declareFunction,
          ClassDeclaration: (node, parents) => {
            let parent = null;
            for (let i = parents.length - 2; i >= 0 && parent === null; i--) {
              if (isScope(parents[i])) {
                parent = parents[i];
              }
            }
            declareLocal(parent, node.id);
          },
          Class: declareClass,
          CatchClause: declareCatchClause,
          ImportDefaultSpecifier: declareModuleSpecifier,
          ImportSpecifier: declareModuleSpecifier,
          ImportNamespaceSpecifier: declareModuleSpecifier
        },
        walk
      );

      function identifier(node, parents) {
        let name = node.name;
        if (name === "undefined") return;
        for (let i = parents.length - 2; i >= 0; --i) {
          if (name === "arguments") {
            if (declaresArguments(parents[i])) {
              return;
            }
          }
          if (hasLocal(parents[i], name)) {
            return;
          }
          if (parents[i].type === "ViewExpression") {
            node = parents[i];
            name = `viewof ${node.id.name}`;
          }
          if (parents[i].type === "MutableExpression") {
            node = parents[i];
            name = `mutable ${node.id.name}`;
          }
        }
        if (!referenceSet.has(name)) {
          if (name === "arguments") {
            throw Object.assign(new ReferenceError(`arguments is not allowed`), {node});
          }
          referenceSet.add(name);
          references.push(node);
        }
      }

      ancestor(
        ast,
        {
          VariablePattern: identifier,
          Identifier: identifier
        },
        walk
      );

      function checkConst(node, parents) {
        switch (node.type) {
          case "Identifier":
          case "VariablePattern": {
            identifier(node, parents);
            break;
          }
          case "ArrayPattern":
          case "ObjectPattern": {
            ancestor(
              node,
              {
                Identifier: identifier,
                VariablePattern: identifier
              },
              walk
            );
            break;
          }
        }
        function identifier(node, nodeParents) {
          for (const parent of parents) {
            if (hasLocal(parent, node.name)) {
              return;
            }
          }
          if (nodeParents[nodeParents.length - 2].type === "MutableExpression") {
            return;
          }
          throw Object.assign(new TypeError(`Assignment to constant variable ${node.name}`), {node});
        }
      }

      function checkConstArgument(node, parents) {
        checkConst(node.argument, parents);
      }

      function checkConstLeft(node, parents) {
        checkConst(node.left, parents);
      }

      ancestor(
        ast,
        {
          AssignmentExpression: checkConstLeft,
          UpdateExpression: checkConstArgument,
          ForOfStatement: checkConstLeft,
          ForInStatement: checkConstLeft
        },
        walk
      );

      return references;
    }

    const SCOPE_FUNCTION$1 = 2;
    const SCOPE_ASYNC$1 = 4;
    const SCOPE_GENERATOR$1 = 8;

    class CellParser extends Parser.extend(acornBigint, dynamicImport) {
      enterScope(flags) {
        if (flags & SCOPE_FUNCTION$1) ++this.O_function;
        return super.enterScope(flags);
      }
      exitScope() {
        if (this.currentScope().flags & SCOPE_FUNCTION$1) --this.O_function;
        return super.exitScope();
      }
      parseForIn(node, init) {
        if (this.O_function === 1 && node.await) this.O_async = true;
        return super.parseForIn(node, init);
      }
      parseAwait() {
        if (this.O_function === 1) this.O_async = true;
        return super.parseAwait();
      }
      parseYield(noIn) {
        if (this.O_function === 1) this.O_generator = true;
        return super.parseYield(noIn);
      }
      parseImport(node) {
        this.next();
        node.specifiers = this.parseImportSpecifiers();
        if (this.type === types._with) {
          this.next();
          node.injections = this.parseImportSpecifiers();
        }
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSpecifiers() {
        const nodes = [];
        let first = true;
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) break;
          }
          const node = this.startNode();
          node.view = this.eatContextual("viewof");
          if (!node.view) node.mutable = this.eatContextual("mutable");
          node.imported = this.parseIdent();
          if (this.eatContextual("as")) {
            node.local = this.parseIdent();
          } else {
            this.checkUnreserved(node.imported);
            node.local = node.imported;
          }
          this.checkLVal(node.local, "let");
          nodes.push(this.finishNode(node, "ImportSpecifier"));
        }
        return nodes;
      }
      parseExprAtom(refDestructuringErrors) {
        return (
          this.parseMaybeKeywordExpression("viewof", "ViewExpression") ||
          this.parseMaybeKeywordExpression("mutable", "MutableExpression") ||
          super.parseExprAtom(refDestructuringErrors)
        );
      }
      parseCell(node, eof) {
        const lookahead = new CellParser({}, this.input, this.start);
        let token = lookahead.getToken();
        let body = null;
        let id = null;

        this.O_function = 0;
        this.O_async = false;
        this.O_generator = false;
        this.strict = true;
        this.enterScope(SCOPE_FUNCTION$1 | SCOPE_ASYNC$1 | SCOPE_GENERATOR$1);

        // An import?
        if (token.type === types._import && lookahead.getToken().type !== types.parenL) {
          body = this.parseImport(this.startNode());
        }

        // A non-empty cell?
        else if (token.type !== types.eof && token.type !== types.semi) {
          // A named cell?
          if (token.type === types.name) {
            if (token.value === "viewof" || token.value === "mutable") {
              token = lookahead.getToken();
              if (token.type !== types.name) {
                lookahead.unexpected();
              }
            }
            token = lookahead.getToken();
            if (token.type === types.eq) {
              id =
                this.parseMaybeKeywordExpression("viewof", "ViewExpression") ||
                this.parseMaybeKeywordExpression("mutable", "MutableExpression") ||
                this.parseIdent();
              token = lookahead.getToken();
              this.expect(types.eq);
            }
          }

          // A block?
          if (token.type === types.braceL) {
            body = this.parseBlock();
          }

          // An expression?
          // Possibly a function or class declaration?
          else {
            body = this.parseExpression();
            if (
              id === null &&
              (body.type === "FunctionExpression" ||
                body.type === "ClassExpression")
            ) {
              id = body.id;
            }
          }
        }

        this.semicolon();
        if (eof) this.expect(types.eof); // TODO

        node.id = id;
        node.async = this.O_async;
        node.generator = this.O_generator;
        node.body = body;
        this.exitScope();
        return this.finishNode(node, "Cell");
      }
      parseTopLevel(node) {
        return this.parseCell(node, true);
      }
      toAssignable(node, isBinding, refDestructuringErrors) {
        return node.type === "MutableExpression"
          ? node
          : super.toAssignable(node, isBinding, refDestructuringErrors);
      }
      checkUnreserved(node) {
        if (node.name === "viewof" || node.name === "mutable") {
          this.raise(node.start, `Unexpected keyword '${node.name}'`);
        }
        return super.checkUnreserved(node);
      }
      checkLVal(expr, bindingType, checkClashes) {
        return super.checkLVal(
          expr.type === "MutableExpression" ? expr.id : expr,
          bindingType,
          checkClashes
        );
      }
      unexpected(pos) {
        this.raise(
          pos != null ? pos : this.start,
          this.type === types.eof ? "Unexpected end of input" : "Unexpected token"
        );
      }
      parseMaybeKeywordExpression(keyword, type) {
        if (this.isContextual(keyword)) {
          const node = this.startNode();
          this.next();
          node.id = this.parseIdent();
          return this.finishNode(node, type);
        }
      }
    }

    function parseModule(input, {globals} = {}) {
      const program = ModuleParser.parse(input);
      for (const cell of program.cells) {
        parseReferences(cell, input, globals);
      }
      return program;
    }

    class ModuleParser extends CellParser {
      parseTopLevel(node) {
        if (!node.cells) node.cells = [];
        while (this.type !== types.eof) {
          const cell = this.parseCell(this.startNode());
          cell.input = this.input;
          node.cells.push(cell);
        }
        this.next();
        return this.finishNode(node, "Program");
      }
    }

    // Find references.
    // Check for illegal references to arguments.
    // Check for illegal assignments to global references.
    function parseReferences(cell, input, globals = defaultGlobals) {
      if (cell.body && cell.body.type !== "ImportDeclaration") {
        try {
          cell.references = findReferences(cell, globals);
        } catch (error) {
          if (error.node) {
            const loc = getLineInfo(input, error.node.start);
            error.message += ` (${loc.line}:${loc.column})`;
            error.pos = error.node.start;
            error.loc = loc;
            delete error.node;
          }
          throw error;
        }
      }
      return cell;
    }

    var toString$1 = Function.prototype.toString;

    function constant(x) {
      return function() {
        return x;
      };
    }

    function canvas(width, height) {
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }

    function context2d(width, height, dpi) {
      if (dpi == null) dpi = devicePixelRatio;
      var canvas = document.createElement("canvas");
      canvas.width = width * dpi;
      canvas.height = height * dpi;
      canvas.style.width = width + "px";
      var context = canvas.getContext("2d");
      context.scale(dpi, dpi);
      return context;
    }

    function download(value, name = "untitled", label = "Save") {
      const a = document.createElement("a");
      const b = a.appendChild(document.createElement("button"));
      b.textContent = label;
      a.download = name;

      async function reset() {
        await new Promise(requestAnimationFrame);
        URL.revokeObjectURL(a.href);
        a.removeAttribute("href");
        b.textContent = label;
        b.disabled = false;
      }

      a.onclick = async event => {
        b.disabled = true;
        if (a.href) return reset(); // Already saved.
        b.textContent = "Saving…";
        try {
          const object = await (typeof value === "function" ? value() : value);
          b.textContent = "Download";
          a.href = URL.createObjectURL(object);
        } catch (ignore) {
          b.textContent = label;
        }
        if (event.eventPhase) return reset(); // Already downloaded.
        b.disabled = false;
      };

      return a;
    }

    var namespaces = {
      math: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xhtml: "http://www.w3.org/1999/xhtml",
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function element(name, attributes) {
      var prefix = name += "", i = prefix.indexOf(":"), value;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      var element = namespaces.hasOwnProperty(prefix)
          ? document.createElementNS(namespaces[prefix], name)
          : document.createElement(name);
      if (attributes) for (var key in attributes) {
        prefix = key, i = prefix.indexOf(":"), value = attributes[key];
        if (i >= 0 && (prefix = key.slice(0, i)) !== "xmlns") key = key.slice(i + 1);
        if (namespaces.hasOwnProperty(prefix)) element.setAttributeNS(namespaces[prefix], key, value);
        else element.setAttribute(key, value);
      }
      return element;
    }

    function input(type) {
      var input = document.createElement("input");
      if (type != null) input.type = type;
      return input;
    }

    function range(min, max, step) {
      if (arguments.length === 1) max = min, min = null;
      var input = document.createElement("input");
      input.min = min = min == null ? 0 : +min;
      input.max = max = max == null ? 1 : +max;
      input.step = step == null ? "any" : step = +step;
      input.type = "range";
      return input;
    }

    function select(values) {
      var select = document.createElement("select");
      Array.prototype.forEach.call(values, function(value) {
        var option = document.createElement("option");
        option.value = option.textContent = value;
        select.appendChild(option);
      });
      return select;
    }

    function svg(width, height) {
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", [0, 0, width, height]);
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
      return svg;
    }

    function text(value) {
      return document.createTextNode(value);
    }

    var count = 0;

    function uid(name) {
      return new Id("O-" + (name == null ? "" : name + "-") + ++count);
    }

    function Id(id) {
      this.id = id;
      this.href = window.location.href + "#" + id;
    }

    Id.prototype.toString = function() {
      return "url(" + this.href + ")";
    };

    var DOM = {
      canvas: canvas,
      context2d: context2d,
      download: download,
      element: element,
      input: input,
      range: range,
      select: select,
      svg: svg,
      text: text,
      uid: uid
    };

    function buffer(file) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader;
        reader.onload = function() { resolve(reader.result); };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    function text$1(file) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader;
        reader.onload = function() { resolve(reader.result); };
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    function url(file) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader;
        reader.onload = function() { resolve(reader.result); };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    var Files = {
      buffer: buffer,
      text: text$1,
      url: url
    };

    function that() {
      return this;
    }

    function disposable(value, dispose) {
      let done = false;
      return {
        [Symbol.iterator]: that,
        next: () => done ? {done: true} : (done = true, {done: false, value}),
        return: () => (done = true, dispose(value), {done: true}),
        throw: () => ({done: done = true})
      };
    }

    function* filter(iterator, test) {
      var result, index = -1;
      while (!(result = iterator.next()).done) {
        if (test(result.value, ++index)) {
          yield result.value;
        }
      }
    }

    function observe(initialize) {
      let stale = false;
      let value;
      let resolve;
      const dispose = initialize(change);

      function change(x) {
        if (resolve) resolve(x), resolve = null;
        else stale = true;
        return value = x;
      }

      function next() {
        return {done: false, value: stale
            ? (stale = false, Promise.resolve(value))
            : new Promise(_ => (resolve = _))};
      }

      return {
        [Symbol.iterator]: that,
        throw: () => ({done: true}),
        return: () => (dispose != null && dispose(), {done: true}),
        next
      };
    }

    function input$1(input) {
      return observe(function(change) {
        var event = eventof(input), value = valueof(input);
        function inputted() { change(valueof(input)); }
        input.addEventListener(event, inputted);
        if (value !== undefined) change(value);
        return function() { input.removeEventListener(event, inputted); };
      });
    }

    function valueof(input) {
      switch (input.type) {
        case "range":
        case "number": return input.valueAsNumber;
        case "date": return input.valueAsDate;
        case "checkbox": return input.checked;
        case "file": return input.multiple ? input.files : input.files[0];
        default: return input.value;
      }
    }

    function eventof(input) {
      switch (input.type) {
        case "button":
        case "submit":
        case "checkbox": return "click";
        case "file": return "change";
        default: return "input";
      }
    }

    function* map(iterator, transform) {
      var result, index = -1;
      while (!(result = iterator.next()).done) {
        yield transform(result.value, ++index);
      }
    }

    function queue(initialize) {
      let resolve;
      const queue = [];
      const dispose = initialize(push);

      function push(x) {
        queue.push(x);
        if (resolve) resolve(queue.shift()), resolve = null;
        return x;
      }

      function next() {
        return {done: false, value: queue.length
            ? Promise.resolve(queue.shift())
            : new Promise(_ => (resolve = _))};
      }

      return {
        [Symbol.iterator]: that,
        throw: () => ({done: true}),
        return: () => (dispose != null && dispose(), {done: true}),
        next
      };
    }

    function* range$1(start, stop, step) {
      start = +start;
      stop = +stop;
      step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
      var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0;
      while (++i < n) {
        yield start + i * step;
      }
    }

    function valueAt(iterator, i) {
      if (!isFinite(i = +i) || i < 0 || i !== i | 0) return;
      var result, index = -1;
      while (!(result = iterator.next()).done) {
        if (++index === i) {
          return result.value;
        }
      }
    }

    function worker(source) {
      const url = URL.createObjectURL(new Blob([source], {type: "text/javascript"}));
      const worker = new Worker(url);
      return disposable(worker, () => {
        worker.terminate();
        URL.revokeObjectURL(url);
      });
    }

    var Generators = {
      disposable: disposable,
      filter: filter,
      input: input$1,
      map: map,
      observe: observe,
      queue: queue,
      range: range$1,
      valueAt: valueAt,
      worker: worker
    };

    function template(render, wrapper) {
      return function(strings) {
        var string = strings[0],
            parts = [], part,
            root = null,
            node, nodes,
            walker,
            i, n, j, m, k = -1;

        // Concatenate the text using comments as placeholders.
        for (i = 1, n = arguments.length; i < n; ++i) {
          part = arguments[i];
          if (part instanceof Node) {
            parts[++k] = part;
            string += "<!--o:" + k + "-->";
          } else if (Array.isArray(part)) {
            for (j = 0, m = part.length; j < m; ++j) {
              node = part[j];
              if (node instanceof Node) {
                if (root === null) {
                  parts[++k] = root = document.createDocumentFragment();
                  string += "<!--o:" + k + "-->";
                }
                root.appendChild(node);
              } else {
                root = null;
                string += node;
              }
            }
            root = null;
          } else {
            string += part;
          }
          string += strings[i];
        }

        // Render the text.
        root = render(string);

        // Walk the rendered content to replace comment placeholders.
        if (++k > 0) {
          nodes = new Array(k);
          walker = document.createTreeWalker(root, NodeFilter.SHOW_COMMENT, null, false);
          while (walker.nextNode()) {
            node = walker.currentNode;
            if (/^o:/.test(node.nodeValue)) {
              nodes[+node.nodeValue.slice(2)] = node;
            }
          }
          for (i = 0; i < k; ++i) {
            if (node = nodes[i]) {
              node.parentNode.replaceChild(parts[i], node);
            }
          }
        }

        // Is the rendered content
        // … a parent of a single child? Detach and return the child.
        // … a document fragment? Replace the fragment with an element.
        // … some other node? Return it.
        return root.childNodes.length === 1 ? root.removeChild(root.firstChild)
            : root.nodeType === 11 ? ((node = wrapper()).appendChild(root), node)
            : root;
      };
    }

    var html = template(function(string) {
      var template = document.createElement("template");
      template.innerHTML = string.trim();
      return document.importNode(template.content, true);
    }, function() {
      return document.createElement("span");
    });

    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     */

    /**
     * Block-Level Grammar
     */

    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: noop,
      hr: /^( *[-*_]){3,} *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
      nptable: noop,
      lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
      blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
      list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
      table: noop,
      paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
      text: /^[^\n]+/
    };

    block.bullet = /(?:[*+-]|\d+\.)/;
    block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
    block.item = replace(block.item, 'gm')
      (/bull/g, block.bullet)
      ();

    block.list = replace(block.list)
      (/bull/g, block.bullet)
      ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
      ('def', '\\n+(?=' + block.def.source + ')')
      ();

    block.blockquote = replace(block.blockquote)
      ('def', block.def)
      ();

    block._tag = '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
      + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
      + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

    block.html = replace(block.html)
      ('comment', /<!--[\s\S]*?-->/)
      ('closed', /<(tag)[\s\S]+?<\/\1>/)
      ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
      (/tag/g, block._tag)
      ();

    block.paragraph = replace(block.paragraph)
      ('hr', block.hr)
      ('heading', block.heading)
      ('lheading', block.lheading)
      ('blockquote', block.blockquote)
      ('tag', '<' + block._tag)
      ('def', block.def)
      ();

    /**
     * Normal Block Grammar
     */

    block.normal = merge({}, block);

    /**
     * GFM Block Grammar
     */

    block.gfm = merge({}, block.normal, {
      fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
      paragraph: /^/,
      heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
    });

    block.gfm.paragraph = replace(block.paragraph)
      ('(?!', '(?!'
        + block.gfm.fences.source.replace('\\1', '\\2') + '|'
        + block.list.source.replace('\\1', '\\3') + '|')
      ();

    /**
     * GFM + Tables Block Grammar
     */

    block.tables = merge({}, block.gfm, {
      nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
      table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
    });

    /**
     * Block Lexer
     */

    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = {};
      this.options = options || marked.defaults;
      this.rules = block.normal;

      if (this.options.gfm) {
        if (this.options.tables) {
          this.rules = block.tables;
        } else {
          this.rules = block.gfm;
        }
      }
    }

    /**
     * Expose Block Rules
     */

    Lexer.rules = block;

    /**
     * Static Lex Method
     */

    Lexer.lex = function(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    };

    /**
     * Preprocessing
     */

    Lexer.prototype.lex = function(src) {
      src = src
        .replace(/\r\n|\r/g, '\n')
        .replace(/\t/g, '    ')
        .replace(/\u00a0/g, ' ')
        .replace(/\u2424/g, '\n');

      return this.token(src, true);
    };

    /**
     * Lexing
     */

    Lexer.prototype.token = function(src, top, bq) {
      var src = src.replace(/^ +$/gm, '')
        , next
        , loose
        , cap
        , bull
        , b
        , item
        , space
        , i
        , l;

      while (src) {
        // newline
        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[0].length > 1) {
            this.tokens.push({
              type: 'space'
            });
          }
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          cap = cap[0].replace(/^ {4}/gm, '');
          this.tokens.push({
            type: 'code',
            text: !this.options.pedantic
              ? cap.replace(/\n+$/, '')
              : cap
          });
          continue;
        }

        // fences (gfm)
        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'code',
            lang: cap[2],
            text: cap[3] || ''
          });
          continue;
        }

        // heading
        if (cap = this.rules.heading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[1].length,
            text: cap[2]
          });
          continue;
        }

        // table no leading pipe (gfm)
        if (top && (cap = this.rules.nptable.exec(src))) {
          src = src.substring(cap[0].length);

          item = {
            type: 'table',
            header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3].replace(/\n$/, '').split('\n')
          };

          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = item.cells[i].split(/ *\| */);
          }

          this.tokens.push(item);

          continue;
        }

        // lheading
        if (cap = this.rules.lheading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[2] === '=' ? 1 : 2,
            text: cap[1]
          });
          continue;
        }

        // hr
        if (cap = this.rules.hr.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'hr'
          });
          continue;
        }

        // blockquote
        if (cap = this.rules.blockquote.exec(src)) {
          src = src.substring(cap[0].length);

          this.tokens.push({
            type: 'blockquote_start'
          });

          cap = cap[0].replace(/^ *> ?/gm, '');

          // Pass `top` to keep the current
          // "toplevel" state. This is exactly
          // how markdown.pl works.
          this.token(cap, top, true);

          this.tokens.push({
            type: 'blockquote_end'
          });

          continue;
        }

        // list
        if (cap = this.rules.list.exec(src)) {
          src = src.substring(cap[0].length);
          bull = cap[2];

          this.tokens.push({
            type: 'list_start',
            ordered: bull.length > 1
          });

          // Get each top-level item.
          cap = cap[0].match(this.rules.item);

          next = false;
          l = cap.length;
          i = 0;

          for (; i < l; i++) {
            item = cap[i];

            // Remove the list item's bullet
            // so it is seen as the next token.
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+\.) +/, '');

            // Outdent whatever the
            // list item contains. Hacky.
            if (~item.indexOf('\n ')) {
              space -= item.length;
              item = !this.options.pedantic
                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                : item.replace(/^ {1,4}/gm, '');
            }

            // Determine whether the next list item belongs here.
            // Backpedal if it does not belong in this list.
            if (this.options.smartLists && i !== l - 1) {
              b = block.bullet.exec(cap[i + 1])[0];
              if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                src = cap.slice(i + 1).join('\n') + src;
                i = l - 1;
              }
            }

            // Determine whether item is loose or not.
            // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
            // for discount behavior.
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose) loose = next;
            }

            this.tokens.push({
              type: loose
                ? 'loose_item_start'
                : 'list_item_start'
            });

            // Recurse.
            this.token(item, false, bq);

            this.tokens.push({
              type: 'list_item_end'
            });
          }

          this.tokens.push({
            type: 'list_end'
          });

          continue;
        }

        // html
        if (cap = this.rules.html.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: this.options.sanitize
              ? 'paragraph'
              : 'html',
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: cap[0]
          });
          continue;
        }

        // def
        if ((!bq && top) && (cap = this.rules.def.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.links[cap[1].toLowerCase()] = {
            href: cap[2],
            title: cap[3]
          };
          continue;
        }

        // table (gfm)
        if (top && (cap = this.rules.table.exec(src))) {
          src = src.substring(cap[0].length);

          item = {
            type: 'table',
            header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
          };

          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = item.cells[i]
              .replace(/^ *\| *| *\| *$/g, '')
              .split(/ *\| */);
          }

          this.tokens.push(item);

          continue;
        }

        // top-level paragraph
        if (top && (cap = this.rules.paragraph.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'paragraph',
            text: cap[1].charAt(cap[1].length - 1) === '\n'
              ? cap[1].slice(0, -1)
              : cap[1]
          });
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          // Top-level should never reach here.
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'text',
            text: cap[0]
          });
          continue;
        }

        if (src) {
          throw new
            Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return this.tokens;
    };

    /**
     * Inline-Level Grammar
     */

    var inline = {
      escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
      autolink: /^<([^ <>]+(@|:\/)[^ <>]+)>/,
      url: noop,
      tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^<'">])*?>/,
      link: /^!?\[(inside)\]\(href\)/,
      reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
      nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
      strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
      em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
      code: /^(`+)([\s\S]*?[^`])\1(?!`)/,
      br: /^ {2,}\n(?!\s*$)/,
      del: noop,
      text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
    };

    inline._inside = /(?:\[[^\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/;
    inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

    inline.link = replace(inline.link)
      ('inside', inline._inside)
      ('href', inline._href)
      ();

    inline.reflink = replace(inline.reflink)
      ('inside', inline._inside)
      ();

    /**
     * Normal Inline Grammar
     */

    inline.normal = merge({}, inline);

    /**
     * Pedantic Inline Grammar
     */

    inline.pedantic = merge({}, inline.normal, {
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
    });

    /**
     * GFM Inline Grammar
     */

    inline.gfm = merge({}, inline.normal, {
      escape: replace(inline.escape)('])', '~|])')(),
      url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
      del: /^~~(?=\S)([\s\S]*?\S)~~/,
      text: replace(inline.text)
        (']|', '~]|')
        ('|', '|https?://|')
        ()
    });

    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline.breaks = merge({}, inline.gfm, {
      br: replace(inline.br)('{2,}', '*')(),
      text: replace(inline.gfm.text)('{2,}', '*')()
    });

    /**
     * Inline Lexer & Compiler
     */

    function InlineLexer(links, options) {
      this.options = options || marked.defaults;
      this.links = links;
      this.rules = inline.normal;
      this.renderer = this.options.renderer || new Renderer;
      this.renderer.options = this.options;

      if (!this.links) {
        throw new
          Error('Tokens array requires a `links` property.');
      }

      if (this.options.gfm) {
        if (this.options.breaks) {
          this.rules = inline.breaks;
        } else {
          this.rules = inline.gfm;
        }
      } else if (this.options.pedantic) {
        this.rules = inline.pedantic;
      }
    }

    /**
     * Expose Inline Rules
     */

    InlineLexer.rules = inline;

    /**
     * Static Lexing/Compiling Method
     */

    InlineLexer.output = function(src, links, options) {
      var inline = new InlineLexer(links, options);
      return inline.output(src);
    };

    /**
     * Lexing/Compiling
     */

    InlineLexer.prototype.output = function(src) {
      var out = ''
        , link
        , text
        , href
        , cap;

      while (src) {
        // escape
        if (cap = this.rules.escape.exec(src)) {
          src = src.substring(cap[0].length);
          out += cap[1];
          continue;
        }

        // autolink
        if (cap = this.rules.autolink.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[2] === '@') {
            text = escape(
              cap[1].charAt(6) === ':'
              ? this.mangle(cap[1].substring(7))
              : this.mangle(cap[1])
            );
            href = this.mangle('mailto:') + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          out += this.renderer.link(href, null, text);
          continue;
        }

        // url (gfm)
        if (!this.inLink && (cap = this.rules.url.exec(src))) {
          src = src.substring(cap[0].length);
          text = escape(cap[1]);
          href = text;
          out += this.renderer.link(href, null, text);
          continue;
        }

        // tag
        if (cap = this.rules.tag.exec(src)) {
          if (!this.inLink && /^<a /i.test(cap[0])) {
            this.inLink = true;
          } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
            this.inLink = false;
          }
          src = src.substring(cap[0].length);
          out += this.options.sanitize
            ? this.options.sanitizer
              ? this.options.sanitizer(cap[0])
              : escape(cap[0])
            : cap[0];
          continue;
        }

        // link
        if (cap = this.rules.link.exec(src)) {
          src = src.substring(cap[0].length);
          this.inLink = true;
          out += this.outputLink(cap, {
            href: cap[2],
            title: cap[3]
          });
          this.inLink = false;
          continue;
        }

        // reflink, nolink
        if ((cap = this.rules.reflink.exec(src))
            || (cap = this.rules.nolink.exec(src))) {
          src = src.substring(cap[0].length);
          link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = this.links[link.toLowerCase()];
          if (!link || !link.href) {
            out += cap[0].charAt(0);
            src = cap[0].substring(1) + src;
            continue;
          }
          this.inLink = true;
          out += this.outputLink(cap, link);
          this.inLink = false;
          continue;
        }

        // strong
        if (cap = this.rules.strong.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.strong(this.output(cap[2] || cap[1]));
          continue;
        }

        // em
        if (cap = this.rules.em.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.em(this.output(cap[2] || cap[1]));
          continue;
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.codespan(escape(cap[2].trim(), true));
          continue;
        }

        // br
        if (cap = this.rules.br.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.br();
          continue;
        }

        // del (gfm)
        if (cap = this.rules.del.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.del(this.output(cap[1]));
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.text(escape(this.smartypants(cap[0])));
          continue;
        }

        if (src) {
          throw new
            Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return out;
    };

    /**
     * Compile Link
     */

    InlineLexer.prototype.outputLink = function(cap, link) {
      var href = escape(link.href)
        , title = link.title ? escape(link.title) : null;

      return cap[0].charAt(0) !== '!'
        ? this.renderer.link(href, title, this.output(cap[1]))
        : this.renderer.image(href, title, escape(cap[1]));
    };

    /**
     * Smartypants Transformations
     */

    InlineLexer.prototype.smartypants = function(text) {
      if (!this.options.smartypants) return text;
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    };

    /**
     * Mangle Links
     */

    InlineLexer.prototype.mangle = function(text) {
      if (!this.options.mangle) return text;
      var out = ''
        , l = text.length
        , i = 0
        , ch;

      for (; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    };

    /**
     * Renderer
     */

    function Renderer(options) {
      this.options = options || {};
    }

    Renderer.prototype.code = function(code, lang, escaped) {
      if (this.options.highlight) {
        var out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }

      if (!lang) {
        return '<pre><code>'
          + (escaped ? code : escape(code, true))
          + '\n</code></pre>';
      }

      return '<pre><code class="'
        + this.options.langPrefix
        + escape(lang, true)
        + '">'
        + (escaped ? code : escape(code, true))
        + '\n</code></pre>\n';
    };

    Renderer.prototype.blockquote = function(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    Renderer.prototype.html = function(html) {
      return html;
    };

    Renderer.prototype.heading = function(text, level, raw) {
      return '<h'
        + level
        + ' id="'
        + this.options.headerPrefix
        + raw.toLowerCase().replace(/[^\w]+/g, '-')
        + '">'
        + text
        + '</h'
        + level
        + '>\n';
    };

    Renderer.prototype.hr = function() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    Renderer.prototype.list = function(body, ordered) {
      var type = ordered ? 'ol' : 'ul';
      return '<' + type + '>\n' + body + '</' + type + '>\n';
    };

    Renderer.prototype.listitem = function(text) {
      return '<li>' + text + '</li>\n';
    };

    Renderer.prototype.paragraph = function(text) {
      return '<p>' + text + '</p>\n';
    };

    Renderer.prototype.table = function(header, body) {
      return '<table>\n'
        + '<thead>\n'
        + header
        + '</thead>\n'
        + '<tbody>\n'
        + body
        + '</tbody>\n'
        + '</table>\n';
    };

    Renderer.prototype.tablerow = function(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    Renderer.prototype.tablecell = function(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align
        ? '<' + type + ' style="text-align:' + flags.align + '">'
        : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    };

    // span level renderer
    Renderer.prototype.strong = function(text) {
      return '<strong>' + text + '</strong>';
    };

    Renderer.prototype.em = function(text) {
      return '<em>' + text + '</em>';
    };

    Renderer.prototype.codespan = function(text) {
      return '<code>' + text + '</code>';
    };

    Renderer.prototype.br = function() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    Renderer.prototype.del = function(text) {
      return '<del>' + text + '</del>';
    };

    Renderer.prototype.link = function(href, title, text) {
      if (this.options.sanitize) {
        try {
          var prot = decodeURIComponent(unescape(href))
            .replace(/[^\w:]/g, '')
            .toLowerCase();
        } catch (e) {
          return text;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return text;
        }
      }
      if (this.options.baseUrl && !originIndependentUrl.test(href)) {
        href = resolveUrl(this.options.baseUrl, href);
      }
      var out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += '>' + text + '</a>';
      return out;
    };

    Renderer.prototype.image = function(href, title, text) {
      if (this.options.baseUrl && !originIndependentUrl.test(href)) {
        href = resolveUrl(this.options.baseUrl, href);
      }
      var out = '<img src="' + href + '" alt="' + text + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    Renderer.prototype.text = function(text) {
      return text;
    };

    /**
     * Parsing & Compiling
     */

    function Parser$1(options) {
      this.tokens = [];
      this.token = null;
      this.options = options || marked.defaults;
      this.options.renderer = this.options.renderer || new Renderer;
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
    }

    /**
     * Static Parse Method
     */

    Parser$1.parse = function(src, options, renderer) {
      var parser = new Parser$1(options, renderer);
      return parser.parse(src);
    };

    /**
     * Parse Loop
     */

    Parser$1.prototype.parse = function(src) {
      this.inline = new InlineLexer(src.links, this.options, this.renderer);
      this.tokens = src.reverse();

      var out = '';
      while (this.next()) {
        out += this.tok();
      }

      return out;
    };

    /**
     * Next Token
     */

    Parser$1.prototype.next = function() {
      return this.token = this.tokens.pop();
    };

    /**
     * Preview Next Token
     */

    Parser$1.prototype.peek = function() {
      return this.tokens[this.tokens.length - 1] || 0;
    };

    /**
     * Parse Text Tokens
     */

    Parser$1.prototype.parseText = function() {
      var body = this.token.text;

      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }

      return this.inline.output(body);
    };

    /**
     * Parse Current Token
     */

    Parser$1.prototype.tok = function() {
      switch (this.token.type) {
        case 'space': {
          return '';
        }
        case 'hr': {
          return this.renderer.hr();
        }
        case 'heading': {
          return this.renderer.heading(
            this.inline.output(this.token.text),
            this.token.depth,
            this.token.text);
        }
        case 'code': {
          return this.renderer.code(this.token.text,
            this.token.lang,
            this.token.escaped);
        }
        case 'table': {
          var header = ''
            , body = ''
            , i
            , row
            , cell
            , flags
            , j;

          // header
          cell = '';
          for (i = 0; i < this.token.header.length; i++) {
            flags = { header: true, align: this.token.align[i] };
            cell += this.renderer.tablecell(
              this.inline.output(this.token.header[i]),
              { header: true, align: this.token.align[i] }
            );
          }
          header += this.renderer.tablerow(cell);

          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];

            cell = '';
            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(
                this.inline.output(row[j]),
                { header: false, align: this.token.align[j] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        }
        case 'blockquote_start': {
          var body = '';

          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }

          return this.renderer.blockquote(body);
        }
        case 'list_start': {
          var body = ''
            , ordered = this.token.ordered;

          while (this.next().type !== 'list_end') {
            body += this.tok();
          }

          return this.renderer.list(body, ordered);
        }
        case 'list_item_start': {
          var body = '';

          while (this.next().type !== 'list_item_end') {
            body += this.token.type === 'text'
              ? this.parseText()
              : this.tok();
          }

          return this.renderer.listitem(body);
        }
        case 'loose_item_start': {
          var body = '';

          while (this.next().type !== 'list_item_end') {
            body += this.tok();
          }

          return this.renderer.listitem(body);
        }
        case 'html': {
          var html = !this.token.pre && !this.options.pedantic
            ? this.inline.output(this.token.text)
            : this.token.text;
          return this.renderer.html(html);
        }
        case 'paragraph': {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }
        case 'text': {
          return this.renderer.paragraph(this.parseText());
        }
      }
    };

    /**
     * Helpers
     */

    function escape(html, encode) {
      return html
        .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function unescape(html) {
    	// explicitly match decimal, hex, and named HTML entities
      return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    function replace(regex, opt) {
      regex = regex.source;
      opt = opt || '';
      return function self(name, val) {
        if (!name) return new RegExp(regex, opt);
        val = val.source || val;
        val = val.replace(/(^|[^\[])\^/g, '$1');
        regex = regex.replace(name, val);
        return self;
      };
    }

    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (/^[^:]+:\/*[^/]*$/.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
        }
      }
      base = baseUrls[' ' + base];

      if (href.slice(0, 2) === '//') {
        return base.replace(/:[\s\S]*/, ':') + href;
      } else if (href.charAt(0) === '/') {
        return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
      } else {
        return base + href;
      }
    }
    var baseUrls = {};
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

    function noop() {}
    noop.exec = noop;

    function merge(obj) {
      var i = 1
        , target
        , key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }


    /**
     * Marked
     */

    function marked(src, opt, callback) {
      if (callback || typeof opt === 'function') {
        if (!callback) {
          callback = opt;
          opt = null;
        }

        opt = merge({}, marked.defaults, opt || {});

        var highlight = opt.highlight
          , tokens
          , pending
          , i = 0;

        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        pending = tokens.length;

        var done = function(err) {
          if (err) {
            opt.highlight = highlight;
            return callback(err);
          }

          var out;

          try {
            out = Parser$1.parse(tokens, opt);
          } catch (e) {
            err = e;
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!pending) return done();

        for (; i < tokens.length; i++) {
          (function(token) {
            if (token.type !== 'code') {
              return --pending || done();
            }
            return highlight(token.text, token.lang, function(err, code) {
              if (err) return done(err);
              if (code == null || code === token.text) {
                return --pending || done();
              }
              token.text = code;
              token.escaped = true;
              --pending || done();
            });
          })(tokens[i]);
        }

        return;
      }
      try {
        if (opt) opt = merge({}, marked.defaults, opt);
        return Parser$1.parse(Lexer.lex(src, opt), opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/chjj/marked.';
        if ((opt || marked.defaults).silent) {
          return '<p>An error occurred:</p><pre>'
            + escape(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      return marked;
    };

    marked.defaults = {
      gfm: true,
      tables: true,
      breaks: false,
      pedantic: false,
      sanitize: false,
      sanitizer: null,
      mangle: true,
      smartLists: false,
      silent: false,
      highlight: null,
      langPrefix: 'lang-',
      smartypants: false,
      headerPrefix: '',
      renderer: new Renderer,
      xhtml: false,
      baseUrl: null
    };

    /**
     * Expose
     */

    marked.Parser = Parser$1;
    marked.parser = Parser$1.parse;

    marked.Renderer = Renderer;

    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;

    marked.InlineLexer = InlineLexer;
    marked.inlineLexer = InlineLexer.output;

    marked.parse = marked;

    const HL_ROOT =
      "https://cdn.jsdelivr.net/npm/@observablehq/highlight.js@2.0.0/";

    function md(require) {
      return function() {
        return template(
          function(string) {
            var root = document.createElement("div");
            root.innerHTML = marked(string, { langPrefix: "" }).trim();
            var code = root.querySelectorAll("pre code[class]");
            if (code.length > 0) {
              require(HL_ROOT + "highlight.min.js").then(function(hl) {
                code.forEach(function(block) {
                  function done() {
                    hl.highlightBlock(block);
                    block.parentNode.classList.add("observablehq--md-pre");
                  }
                  if (hl.getLanguage(block.className)) {
                    done();
                  } else {
                    require(HL_ROOT + "async-languages/index.js")
                      .then(index => {
                        if (index.has(block.className)) {
                          return require(HL_ROOT +
                            "async-languages/" +
                            index.get(block.className)).then(language => {
                            hl.registerLanguage(block.className, language);
                          });
                        }
                      })
                      .then(done, done);
                  }
                });
              });
            }
            return root;
          },
          function() {
            return document.createElement("div");
          }
        );
      };
    }

    function Mutable(value) {
      let change;
      Object.defineProperties(this, {
        generator: {value: observe(_ => void (change = _))},
        value: {get: () => value, set: x => change(value = x)}
      });
      if (value !== undefined) change(value);
    }

    function* now() {
      while (true) {
        yield Date.now();
      }
    }

    function delay(duration, value) {
      return new Promise(function(resolve) {
        setTimeout(function() {
          resolve(value);
        }, duration);
      });
    }

    var timeouts = new Map;

    function timeout(now, time) {
      var t = new Promise(function(resolve) {
        timeouts.delete(time);
        var delay = time - now;
        if (!(delay > 0)) throw new Error("invalid time");
        if (delay > 0x7fffffff) throw new Error("too long to wait");
        setTimeout(resolve, delay);
      });
      timeouts.set(time, t);
      return t;
    }

    function when(time, value) {
      var now;
      return (now = timeouts.get(time = +time)) ? now.then(constant(value))
          : (now = Date.now()) >= time ? Promise.resolve(value)
          : timeout(now, time).then(constant(value));
    }

    function tick(duration, value) {
      return when(Math.ceil((Date.now() + 1) / duration) * duration, value);
    }

    var Promises = {
      delay: delay,
      tick: tick,
      when: when
    };

    function resolve(name, base) {
      if (/^(\w+:)|\/\//i.test(name)) return name;
      if (/^[.]{0,2}\//i.test(name)) return new URL(name, base == null ? location : base).href;
      if (!name.length || /^[\s._]/.test(name) || /\s$/.test(name)) throw new Error("illegal name");
      return "https://unpkg.com/" + name;
    }

    const metas = new Map;
    const queue$1 = [];
    const map$1 = queue$1.map;
    const some = queue$1.some;
    const hasOwnProperty$1 = queue$1.hasOwnProperty;
    const origin = "https://cdn.jsdelivr.net/npm/";
    const identifierRe = /^((?:@[^/@]+\/)?[^/@]+)(?:@([^/]+))?(?:\/(.*))?$/;
    const versionRe = /^\d+\.\d+\.\d+(-[\w-.+]+)?$/;
    const extensionRe = /\.[^/]*$/;
    const mains = ["unpkg", "jsdelivr", "browser", "main"];

    class RequireError extends Error {
      constructor(message) {
        super(message);
      }
    }

    RequireError.prototype.name = RequireError.name;

    function main(meta) {
      for (const key of mains) {
        const value = meta[key];
        if (typeof value === "string") {
          return extensionRe.test(value) ? value : `${value}.js`;
        }
      }
    }

    function parseIdentifier(identifier) {
      const match = identifierRe.exec(identifier);
      return match && {
        name: match[1],
        version: match[2],
        path: match[3]
      };
    }

    function resolveMeta(target) {
      const url = `${origin}${target.name}${target.version ? `@${target.version}` : ""}/package.json`;
      let meta = metas.get(url);
      if (!meta) metas.set(url, meta = fetch(url).then(response => {
        if (!response.ok) throw new RequireError("unable to load package.json");
        if (response.redirected && !metas.has(response.url)) metas.set(response.url, meta);
        return response.json();
      }));
      return meta;
    }

    async function resolve$1(name, base) {
      if (name.startsWith(origin)) name = name.substring(origin.length);
      if (/^(\w+:)|\/\//i.test(name)) return name;
      if (/^[.]{0,2}\//i.test(name)) return new URL(name, base == null ? location : base).href;
      if (!name.length || /^[\s._]/.test(name) || /\s$/.test(name)) throw new RequireError("illegal name");
      const target = parseIdentifier(name);
      if (!target) return `${origin}${name}`;
      if (!target.version && base != null && base.startsWith(origin)) {
        const meta = await resolveMeta(parseIdentifier(base.substring(origin.length)));
        target.version = meta.dependencies && meta.dependencies[target.name] || meta.peerDependencies && meta.peerDependencies[target.name];
      }
      if (target.path && !extensionRe.test(target.path)) target.path += ".js";
      if (target.path && target.version && versionRe.test(target.version)) return `${origin}${target.name}@${target.version}/${target.path}`;
      const meta = await resolveMeta(target);
      return `${origin}${meta.name}@${meta.version}/${target.path || main(meta) || "index.js"}`;
    }

    const require = requireFrom(resolve$1);

    function requireFrom(resolver) {
      const cache = new Map;
      const requireBase = requireRelative(null);

      function requireAbsolute(url) {
        if (typeof url !== "string") return url;
        let module = cache.get(url);
        if (!module) cache.set(url, module = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.onload = () => {
            try { resolve(queue$1.pop()(requireRelative(url))); }
            catch (error) { reject(new RequireError("invalid module")); }
            script.remove();
          };
          script.onerror = () => {
            reject(new RequireError("unable to load module"));
            script.remove();
          };
          script.async = true;
          script.src = url;
          window.define = define;
          document.head.appendChild(script);
        }));
        return module;
      }

      function requireRelative(base) {
        return name => Promise.resolve(resolver(name, base)).then(requireAbsolute);
      }

      function requireAlias(aliases) {
        return requireFrom((name, base) => {
          if (name in aliases) {
            name = aliases[name], base = null;
            if (typeof name !== "string") return name;
          }
          return resolver(name, base);
        });
      }

      function require(name) {
        return arguments.length > 1
            ? Promise.all(map$1.call(arguments, requireBase)).then(merge$1)
            : requireBase(name);
      }

      require.alias = requireAlias;
      require.resolve = resolver;

      return require;
    }

    function merge$1(modules) {
      const o = {};
      for (const m of modules) {
        for (const k in m) {
          if (hasOwnProperty$1.call(m, k)) {
            if (m[k] == null) Object.defineProperty(o, k, {get: getter(m, k)});
            else o[k] = m[k];
          }
        }
      }
      return o;
    }

    function getter(object, name) {
      return () => object[name];
    }

    function isexports(name) {
      return (name + "") === "exports";
    }

    function define(name, dependencies, factory) {
      const n = arguments.length;
      if (n < 2) factory = name, dependencies = [];
      else if (n < 3) factory = dependencies, dependencies = typeof name === "string" ? [] : name;
      queue$1.push(some.call(dependencies, isexports) ? require => {
        const exports = {};
        return Promise.all(map$1.call(dependencies, name => {
          return isexports(name += "") ? exports : require(name);
        })).then(dependencies => {
          factory.apply(null, dependencies);
          return exports;
        });
      } : require => {
        return Promise.all(map$1.call(dependencies, require)).then(dependencies => {
          return typeof factory === "function" ? factory.apply(null, dependencies) : factory;
        });
      });
    }

    define.amd = {};

    function requirer(resolve) {
      return resolve == null ? require : requireFrom(resolve);
    }

    var svg$1 = template(function(string) {
      var root = document.createElementNS("http://www.w3.org/2000/svg", "g");
      root.innerHTML = string.trim();
      return root;
    }, function() {
      return document.createElementNS("http://www.w3.org/2000/svg", "g");
    });

    var raw = String.raw;

    function style(href) {
      return new Promise(function(resolve, reject) {
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = href;
        link.onerror = reject;
        link.onload = resolve;
        document.head.appendChild(link);
      });
    }

    function tex(require) {
      return function() {
        return Promise.all([
          require("@observablehq/katex@0.10.1/dist/katex.min.js"),
          require.resolve("@observablehq/katex@0.10.1/dist/katex.min.css").then(style)
        ]).then(function(values) {
          var katex = values[0], tex = renderer();

          function renderer(options) {
            return function() {
              var root = document.createElement("div");
              katex.render(raw.apply(String, arguments), root, options);
              return root.removeChild(root.firstChild);
            };
          }

          tex.options = renderer;
          tex.block = renderer({displayMode: true});
          return tex;
        });
      };
    }

    function width() {
      return observe(function(change) {
        var width = change(document.body.clientWidth);
        function resized() {
          var w = document.body.clientWidth;
          if (w !== width) change(width = w);
        }
        window.addEventListener("resize", resized);
        return function() {
          window.removeEventListener("resize", resized);
        };
      });
    }

    function Library(resolver) {
      const require = requirer(resolver);
      Object.defineProperties(this, {
        DOM: {value: DOM, writable: true, enumerable: true},
        Files: {value: Files, writable: true, enumerable: true},
        Generators: {value: Generators, writable: true, enumerable: true},
        html: {value: constant(html), writable: true, enumerable: true},
        md: {value: md(require), writable: true, enumerable: true},
        Mutable: {value: constant(Mutable), writable: true, enumerable: true},
        now: {value: now, writable: true, enumerable: true},
        Promises: {value: Promises, writable: true, enumerable: true},
        require: {value: constant(require), writable: true, enumerable: true},
        resolve: {value: constant(resolve), writable: true, enumerable: true},
        svg: {value: constant(svg$1), writable: true, enumerable: true},
        tex: {value: tex(require), writable: true, enumerable: true},
        width: {value: width, writable: true, enumerable: true}
      });
    }

    function RuntimeError(message, input) {
      this.message = message + "";
      this.input = input;
    }

    RuntimeError.prototype = Object.create(Error.prototype);
    RuntimeError.prototype.name = "RuntimeError";
    RuntimeError.prototype.constructor = RuntimeError;

    function generatorish(value) {
      return value
          && typeof value.next === "function"
          && typeof value.return === "function";
    }

    function load(notebook, library, observer) {
      if (typeof library == "function") observer = library, library = null;
      if (typeof observer !== "function") throw new Error("invalid observer");
      if (library == null) library = new Library();

      const {modules, id} = notebook;
      const map = new Map;
      const runtime = new Runtime(library);
      const main = runtime_module(id);

      function runtime_module(id) {
        let module = map.get(id);
        if (!module) map.set(id, module = runtime.module());
        return module;
      }

      for (const m of modules) {
        const module = runtime_module(m.id);
        let i = 0;
        for (const v of m.variables) {
          if (v.from) module.import(v.remote, v.name, runtime_module(v.from));
          else if (module === main) module.variable(observer(v, i, m.variables)).define(v.name, v.inputs, v.value);
          else module.define(v.name, v.inputs, v.value);
          ++i;
        }
      }

      return runtime;
    }

    var prototype = Array.prototype;
    var map$2 = prototype.map;
    var forEach = prototype.forEach;

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    function identity(x) {
      return x;
    }

    function rethrow(e) {
      return function() {
        throw e;
      };
    }

    function noop$1() {}

    var TYPE_NORMAL = 1; // a normal variable
    var TYPE_IMPLICIT = 2; // created on reference
    var TYPE_DUPLICATE = 3; // created on duplicate definition

    var no_observer = {};

    function Variable(type, module, observer) {
      if (observer == null) observer = no_observer;
      Object.defineProperties(this, {
        _observer: {value: observer, writable: true},
        _definition: {value: variable_undefined, writable: true},
        _duplicate: {value: undefined, writable: true},
        _duplicates: {value: undefined, writable: true},
        _indegree: {value: -1, writable: true}, // The number of computing inputs.
        _inputs: {value: [], writable: true},
        _invalidate: {value: noop$1, writable: true},
        _module: {value: module},
        _name: {value: null, writable: true},
        _outputs: {value: new Set, writable: true},
        _promise: {value: Promise.resolve(undefined), writable: true},
        _reachable: {value: observer !== no_observer, writable: true}, // Is this variable transitively visible?
        _rejector: {value: variable_rejector(this)},
        _type: {value: type},
        _value: {value: undefined, writable: true},
        _version: {value: 0, writable: true}
      });
    }

    Object.defineProperties(Variable.prototype, {
      _pending: {value: variable_pending, writable: true, configurable: true},
      _fulfilled: {value: variable_fulfilled, writable: true, configurable: true},
      _rejected: {value: variable_rejected, writable: true, configurable: true},
      define: {value: variable_define, writable: true, configurable: true},
      delete: {value: variable_delete, writable: true, configurable: true},
      import: {value: variable_import, writable: true, configurable: true}
    });

    function variable_attach(variable) {
      variable._module._runtime._dirty.add(variable);
      variable._outputs.add(this);
    }

    function variable_detach(variable) {
      variable._module._runtime._dirty.add(variable);
      variable._outputs.delete(this);
    }

    function variable_undefined() {
      throw variable_undefined;
    }

    function variable_rejector(variable) {
      return function(error) {
        if (error === variable_undefined) throw new RuntimeError(variable._name + " is not defined", variable._name);
        throw new RuntimeError(variable._name + " could not be resolved", variable._name);
      };
    }

    function variable_duplicate(name) {
      return function() {
        throw new RuntimeError(name + " is defined more than once");
      };
    }

    function variable_define(name, inputs, definition) {
      switch (arguments.length) {
        case 1: {
          definition = name, name = inputs = null;
          break;
        }
        case 2: {
          definition = inputs;
          if (typeof name === "string") inputs = null;
          else inputs = name, name = null;
          break;
        }
      }
      return variable_defineImpl.call(this,
        name == null ? null : name + "",
        inputs == null ? [] : map$2.call(inputs, this._module._resolve, this._module),
        typeof definition === "function" ? definition : constant$1(definition)
      );
    }

    function variable_defineImpl(name, inputs, definition) {
      var scope = this._module._scope, runtime = this._module._runtime;

      this._inputs.forEach(variable_detach, this);
      inputs.forEach(variable_attach, this);
      this._inputs = inputs;
      this._definition = definition;
      this._value = undefined;

      // Did the variable’s name change? Time to patch references!
      if (name == this._name && scope.get(name) === this) {
        this._outputs.forEach(runtime._updates.add, runtime._updates);
      } else {
        var error, found;

        if (this._name) { // Did this variable previously have a name?
          if (this._outputs.size) { // And did other variables reference this variable?
            scope.delete(this._name);
            found = this._module._resolve(this._name);
            found._outputs = this._outputs, this._outputs = new Set;
            found._outputs.forEach(function(output) { output._inputs[output._inputs.indexOf(this)] = found; }, this);
            found._outputs.forEach(runtime._updates.add, runtime._updates);
            runtime._dirty.add(found).add(this);
            scope.set(this._name, found);
          } else if ((found = scope.get(this._name)) === this) { // Do no other variables reference this variable?
            scope.delete(this._name); // It’s safe to delete!
          } else if (found._type === TYPE_DUPLICATE) { // Do other variables assign this name?
            found._duplicates.delete(this); // This variable no longer assigns this name.
            this._duplicate = undefined;
            if (found._duplicates.size === 1) { // Is there now only one variable assigning this name?
              found = found._duplicates.keys().next().value; // Any references are now fixed!
              error = scope.get(this._name);
              found._outputs = error._outputs, error._outputs = new Set;
              found._outputs.forEach(function(output) { output._inputs[output._inputs.indexOf(error)] = found; });
              found._definition = found._duplicate, found._duplicate = undefined;
              runtime._dirty.add(error).add(found);
              runtime._updates.add(found);
              scope.set(this._name, found);
            }
          } else {
            throw new Error;
          }
        }

        if (this._outputs.size) throw new Error;

        if (name) { // Does this variable have a new name?
          if (found = scope.get(name)) { // Do other variables reference or assign this name?
            if (found._type === TYPE_DUPLICATE) { // Do multiple other variables already define this name?
              this._definition = variable_duplicate(name), this._duplicate = definition;
              found._duplicates.add(this);
            } else if (found._type === TYPE_IMPLICIT) { // Are the variable references broken?
              this._outputs = found._outputs, found._outputs = new Set; // Now they’re fixed!
              this._outputs.forEach(function(output) { output._inputs[output._inputs.indexOf(found)] = this; }, this);
              runtime._dirty.add(found).add(this);
              scope.set(name, this);
            } else { // Does another variable define this name?
              found._duplicate = found._definition, this._duplicate = definition; // Now they’re duplicates.
              error = new Variable(TYPE_DUPLICATE, this._module);
              error._name = name;
              error._definition = this._definition = found._definition = variable_duplicate(name);
              error._outputs = found._outputs, found._outputs = new Set;
              error._outputs.forEach(function(output) { output._inputs[output._inputs.indexOf(found)] = error; });
              error._duplicates = new Set([this, found]);
              runtime._dirty.add(found).add(error);
              runtime._updates.add(found).add(error);
              scope.set(name, error);
            }
          } else {
            scope.set(name, this);
          }
        }

        this._name = name;
      }

      runtime._updates.add(this);
      runtime._compute();
      return this;
    }

    function variable_import(remote, name, module) {
      if (arguments.length < 3) module = name, name = remote;
      return variable_defineImpl.call(this, name + "", [module._resolve(remote + "")], identity);
    }

    function variable_delete() {
      return variable_defineImpl.call(this, null, [], noop$1);
    }

    function variable_pending() {
      if (this._observer.pending) this._observer.pending();
    }

    function variable_fulfilled(value) {
      if (this._observer.fulfilled) this._observer.fulfilled(value, this._name);
    }

    function variable_rejected(error) {
      if (this._observer.rejected) this._observer.rejected(error, this._name);
    }

    var none = new Map;

    function Module(runtime) {
      Object.defineProperties(this, {
        _runtime: {value: runtime},
        _scope: {value: new Map}
      });
    }

    Object.defineProperties(Module.prototype, {
      _copy: {value: module_copy, writable: true, configurable: true},
      _resolve: {value: module_resolve, writable: true, configurable: true},
      redefine: {value: module_redefine, writable: true, configurable: true},
      define: {value: module_define, writable: true, configurable: true},
      derive: {value: module_derive, writable: true, configurable: true},
      import: {value: module_import, writable: true, configurable: true},
      variable: {value: module_variable, writable: true, configurable: true}
    });

    function module_redefine(name) {
      var v = this._scope.get(name);
      if (!v) throw new RuntimeError(name + " is not defined");
      if (v._type === TYPE_DUPLICATE) throw new RuntimeError(name + " is defined more than once");
      return v.define.apply(v, arguments);
    }

    function module_define() {
      var v = new Variable(TYPE_NORMAL, this);
      return v.define.apply(v, arguments);
    }

    function module_import() {
      var v = new Variable(TYPE_NORMAL, this);
      return v.import.apply(v, arguments);
    }

    function module_variable(observer) {
      return new Variable(TYPE_NORMAL, this, observer);
    }

    function module_derive(injects, injectModule) {
      var injectByAlias = new Map;
      forEach.call(injects, function(inject) {
        if (typeof inject !== "object") inject = {name: inject + ""};
        if (inject.alias == null) inject.alias = inject.name;
        injectByAlias.set(inject.alias, inject);
      });
      return this._copy(injectByAlias, injectModule, new Map);
    }

    function module_copy(injectByAlias, injectModule, map) {
      var copy = new Module(this._runtime);
      map.set(this, copy);
      this._scope.forEach(function(source, name) {
        var target = new Variable(source._type, copy), inject;
        if (inject = injectByAlias.get(name)) {
          target.import(inject.name, inject.alias, injectModule);
        } else if (source._definition === identity) { // import!
          var sourceInput = source._inputs[0],
              sourceModule = sourceInput._module,
              targetModule = map.get(sourceModule) || sourceModule._copy(none, null, map);
          target.import(sourceInput._name, name, targetModule);
        } else {
          target.define(name, source._inputs.map(variable_name), source._definition);
        }
      });
      return copy;
    }

    function module_resolve(name) {
      var variable = this._scope.get(name), value;
      if (!variable)  {
        variable = new Variable(TYPE_IMPLICIT, this);
        if (this._runtime._builtin._scope.has(name)) {
          variable.import(name, this._runtime._builtin);
        } else if (name === "invalidation") {
          variable.define(name, variable_invalidation);
        } else if (name === "visibility") {
          variable.define(name, variable_visibility);
        } else {
          try {
            value = this._runtime._global(name);
          } catch (error) {
            return variable.define(name, rethrow(error));
          }
          if (value === undefined) {
            this._scope.set(variable._name = name, variable);
          } else {
            variable.define(name, constant$1(value));
          }
        }
      }
      return variable;
    }

    function variable_name(variable) {
      return variable._name;
    }

    const frame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setImmediate;

    var variable_invalidation = {};
    var variable_visibility = {};

    function Runtime(builtins = new Library, global = window_global) {
      var builtin = this.module();
      Object.defineProperties(this, {
        _dirty: {value: new Set},
        _updates: {value: new Set},
        _computing: {value: null, writable: true},
        _modules: {value: new Map},
        _builtin: {value: builtin},
        _global: {value: global}
      });
      if (builtins) for (var name in builtins) {
        (new Variable(TYPE_IMPLICIT, builtin)).define(name, [], builtins[name]);
      }
    }

    Object.defineProperties(Runtime, {
      load: {value: load, writable: true, configurable: true}
    });

    Object.defineProperties(Runtime.prototype, {
      _compute: {value: runtime_compute, writable: true, configurable: true},
      _computeSoon: {value: runtime_computeSoon, writable: true, configurable: true},
      _computeNow: {value: runtime_computeNow, writable: true, configurable: true},
      module: {value: runtime_module, writable: true, configurable: true}
    });

    function runtime_module(define, observer = noop$1) {
      if (define === undefined) return new Module(this);
      let module = this._modules.get(define);
      if (module) return module;
      this._modules.set(define, module = define(this, observer));
      return module;
    }

    function runtime_compute() {
      return this._computing || (this._computing = this._computeSoon());
    }

    function runtime_computeSoon() {
      var runtime = this;
      return new Promise(function(resolve) {
        frame(function() {
          resolve();
          runtime._computeNow();
        });
      });
    }

    function runtime_computeNow() {
      var queue = [],
          variables,
          variable;

      // Compute the reachability of the transitive closure of dirty variables.
      // Any newly-reachable variable must also be recomputed.
      // Any no-longer-reachable variable must be terminated.
      variables = new Set(this._dirty);
      variables.forEach(function(variable) {
        variable._inputs.forEach(variables.add, variables);
        const reachable = variable_reachable(variable);
        if (reachable > variable._reachable) {
          this._updates.add(variable);
        } else if (reachable < variable._reachable) {
          variable._invalidate();
        }
        variable._reachable = reachable;
      }, this);

      // Compute the transitive closure of updating, reachable variables.
      variables = new Set(this._updates);
      variables.forEach(function(variable) {
        if (variable._reachable) {
          variable._indegree = 0;
          variable._outputs.forEach(variables.add, variables);
        } else {
          variable._indegree = -1;
          variables.delete(variable);
        }
      });

      this._computing = null;
      this._updates.clear();
      this._dirty.clear();

      // Compute the indegree of updating variables.
      variables.forEach(function(variable) {
        variable._outputs.forEach(variable_increment);
      });

      // Identify the root variables (those with no updating inputs).
      variables.forEach(function(variable) {
        if (variable._indegree === 0) {
          queue.push(variable);
        }
      });

      // Compute the variables in topological order.
      while (variable = queue.pop()) {
        variable_compute(variable);
        variable._outputs.forEach(postqueue);
        variables.delete(variable);
      }

      // Any remaining variables have circular definitions.
      variables.forEach(function(variable) {
        var error = new RuntimeError("circular definition");
        variable._value = undefined;
        (variable._promise = Promise.reject(error)).catch(noop$1);
        variable._rejected(error);
      });

      function postqueue(variable) {
        if (--variable._indegree === 0) {
          queue.push(variable);
        }
      }
    }

    function variable_increment(variable) {
      ++variable._indegree;
    }

    function variable_value(variable) {
      return variable._promise.catch(variable._rejector);
    }

    function variable_invalidator(variable) {
      return new Promise(function(resolve) {
        variable._invalidate = resolve;
      });
    }

    function variable_intersector(invalidation, variable) {
      let node = typeof IntersectionObserver === "function" && variable._observer && variable._observer._node;
      let visible = !node, resolve = noop$1, reject = noop$1, promise, observer;
      if (node) {
        observer = new IntersectionObserver(([entry]) => (visible = entry.isIntersecting) && (promise = null, resolve()));
        observer.observe(node);
        invalidation.then(() => (observer.disconnect(), observer = null, reject()));
      }
      return function(value) {
        if (visible) return Promise.resolve(value);
        if (!observer) return Promise.reject();
        if (!promise) promise = new Promise((y, n) => (resolve = y, reject = n));
        return promise.then(() => value);
      };
    }

    function variable_compute(variable) {
      variable._invalidate();
      variable._invalidate = noop$1;
      variable._pending();
      var value0 = variable._value,
          version = ++variable._version,
          invalidation = null,
          promise = variable._promise = Promise.all(variable._inputs.map(variable_value)).then(function(inputs) {
        if (variable._version !== version) return;

        // Replace any reference to invalidation with the promise, lazily.
        for (var i = 0, n = inputs.length; i < n; ++i) {
          switch (inputs[i]) {
            case variable_invalidation: {
              inputs[i] = invalidation = variable_invalidator(variable);
              break;
            }
            case variable_visibility: {
              if (!invalidation) invalidation = variable_invalidator(variable);
              inputs[i] = variable_intersector(invalidation, variable);
              break;
            }
          }
        }

        // Compute the initial value of the variable.
        return variable._definition.apply(value0, inputs);
      }).then(function(value) {
        // If the value is a generator, then retrieve its first value,
        // and dispose of the generator if the variable is invalidated.
        if (generatorish(value)) {
          (invalidation || variable_invalidator(variable)).then(variable_return(value));
          return variable_precompute(variable, version, promise, value);
        }
        return value;
      });
      promise.then(function(value) {
        if (variable._version !== version) return;
        variable._value = value;
        variable._fulfilled(value);
      }, function(error) {
        if (variable._version !== version) return;
        variable._value = undefined;
        variable._rejected(error);
      });
    }

    function variable_precompute(variable, version, promise, generator) {
      function recompute() {
        var promise = new Promise(function(resolve) {
          resolve(generator.next());
        }).then(function(next) {
          return next.done ? undefined : Promise.resolve(next.value).then(function(value) {
            if (variable._version !== version) return;
            variable_postrecompute(variable, value, promise).then(recompute);
            variable._fulfilled(value);
            return value;
          });
        });
        promise.catch(function(error) {
          if (variable._version !== version) return;
          variable_postrecompute(variable, undefined, promise);
          variable._rejected(error);
        });
      }
      return new Promise(function(resolve) {
        resolve(generator.next());
      }).then(function(next) {
        if (next.done) return;
        promise.then(recompute);
        return next.value;
      });
    }

    function variable_postrecompute(variable, value, promise) {
      var runtime = variable._module._runtime;
      variable._value = value;
      variable._promise = promise;
      variable._outputs.forEach(runtime._updates.add, runtime._updates); // TODO Cleaner?
      return runtime._compute();
    }

    function variable_return(generator) {
      return function() {
        generator.return();
      };
    }

    function variable_reachable(variable) {
      if (variable._observer !== no_observer) return true; // Directly reachable.
      var outputs = new Set(variable._outputs);
      for (const output of outputs) {
        if (output._observer !== no_observer) return true;
        output._outputs.forEach(outputs.add, outputs);
      }
      return false;
    }

    function window_global(name) {
      return window[name];
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = new Date(+date)), date;
      }

      interval.floor = interval;

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var day = newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function(date) {
      return date.getDate() - 1;
    });

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newYear(y) {
      return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, newDate) {
        return function(string) {
          var d = newYear(1900),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = newDate(newYear(d.y)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return newDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", localDate);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier, utcDate);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {}, i = -1, n = names.length;
      while (++i < n) map[names[i].toLowerCase()] = i;
      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d), d), p, 2);
    }

    function formatWeekNumberISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d), d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d), d), p, 2);
    }

    function formatUTCWeekNumberISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d), d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    // import * as winston from "winston";
    const logDate = timeFormat("%Y-%m-%d %H-%M-%S.%L");

    const getStat = (filename) => new Promise(function (res, rej) {
        fs.stat(filename, (err, stat) => {
            if (err) {
                if (err.code === "ENOENT") {
                    res(null);
                    return;
                }
                rej(err);
            }
            res(stat);
        });
    });
    function parseOakfile(path) {
        return new Promise((resolve, reject) => {
            fs.readFile(path, "utf8", (err, contents) => {
                if (err)
                    reject(err);
                try {
                    const oakModule = parseModule(contents);
                    resolve(oakModule);
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    }

    const executeCommand = (command) => {
        const e = new events.EventEmitter();
        const process = child_process.spawn(command, { shell: true });
        console.log(`[executeCommand]running command ${command}`);
        process.stdout.on("data", chunk => {
            e.emit("stdout", chunk);
        });
        process.stderr.on("data", chunk => {
            e.emit("stderr", chunk);
        });
        process.on("close", (code) => __awaiter(undefined, void 0, void 0, function* () {
            e.emit("close", code);
        }));
        process.on("error", () => {
            e.emit("error");
        });
        return e;
    };
    function bash(args = {}) {
        function transform(strings, ...values) {
            //console.debug(`!! BASH HERE`, strings, values);
            let s = strings[0];
            for (let i = 0, n = values.length; i < n; ++i)
                s +=
                    typeof values[i] === "string"
                        ? `"${values[i].replace(`"`, `"`)}"${strings[i + 1]}`
                        : `"${values[i].path.replace(`"`, `"`)}"${strings[i + 1]}`;
            return new Promise((resolve, reject) => executeCommand(s)
                .on("stdout", chunk => {
                process.stdout.write(chunk);
            })
                .on("stderr", chunk => {
                process.stderr.write(chunk);
            })
                .on("close", (code) => __awaiter(this, void 0, void 0, function* () {
                resolve(s);
            }))
                .on("error", () => {
                process = null;
                console.error(`Process errored`);
                reject("error");
            }));
        }
        return Array.isArray(args)
            ? ((args = {}), transform.apply(this, arguments))
            : transform;
    }
    class FileInfo {
        constructor(path, stat, recipe) {
            this.path = path;
            this.stat = stat;
            this.recipe = recipe;
        }
        runRecipe() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.recipe(this.path);
            });
        }
    }
    function cell(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { path, recipe } = params;
            const stat = yield getStat(path);
            return new FileInfo(path, stat, recipe);
        });
    }
    var Library$1 = {
        bash: () => bash,
        cell: () => cell
    };

    const AsyncFunction = Object.getPrototypeOf(function () {
        return __awaiter(this, void 0, void 0, function* () { });
    }).constructor;
    const GeneratorFunction = Object.getPrototypeOf(function* () { }).constructor;
    const AsyncGeneratorFunction = Object.getPrototypeOf(function () { return __asyncGenerator(this, arguments, function* () { }); })
        .constructor;
    function oak_static(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const runtime = new Runtime(Library$1, {});
            const inspector = {
                pending() {
                    console.log(`pending`);
                },
                fulfilled(value) {
                    console.log(`${value} fulfilled`);
                },
                rejected(error) {
                    console.error(`${error} rejected`);
                }
            };
            const oakfileContents = yield new Promise((resolve, reject) => {
                fs.readFile(args.filename, "utf8", (err, contents) => {
                    if (err)
                        reject(err);
                    resolve(contents);
                });
            });
            const parseResults = parseModule(oakfileContents);
            const m = runtime.module();
            parseResults.cells.map(cell => {
                let name = null;
                if (cell.id && cell.id.name)
                    name = cell.id.name;
                if (cell.body.type === "ImportDeclaration") {
                    throw Error(`Pls implement import handling`);
                }
                const bodyText = oakfileContents.substring(cell.body.start, cell.body.end);
                let code;
                if (cell.body.type !== "BlockStatement") {
                    if (cell.async)
                        code = `return (async function(){ return (${bodyText});})()`;
                    else
                        code = `return (function(){ return (${bodyText});})()`;
                }
                else
                    code = bodyText;
                const references = cell.references.map(ref => {
                    if (ref.type === "ViewExpression")
                        throw Error("ViewExpression wat");
                    return ref.name;
                });
                let f;
                if (cell.generator && cell.async)
                    f = new AsyncGeneratorFunction(...references, code);
                else if (cell.async)
                    f = new AsyncFunction(...references, code);
                else if (cell.generator)
                    f = new GeneratorFunction(...references, code);
                else
                    f = new Function(...references, code);
                m.variable(inspector).define(name, references, function (...dependencies) {
                    return __awaiter(this, void 0, void 0, function* () {
                        // dont try and get fileinfo for cell depends like `cell` or `bash`
                        let cellDependents = [];
                        dependencies.map(dependency => {
                            if (dependency instanceof FileInfo) {
                                cellDependents.push(dependency);
                            }
                        });
                        let currCell = yield f(...dependencies);
                        if (currCell instanceof FileInfo) {
                            // run recipe if no file or if it's out of date
                            if (currCell.stat === null) {
                                console.log(`Running recipe for ${currCell.path} because it doesnt exist`);
                                yield currCell.runRecipe();
                                currCell.stat = yield getStat(currCell.path);
                                return currCell;
                            }
                            const deps = cellDependents.filter(c => currCell.stat.mtime < c.stat.mtime);
                            if (deps.length > 0) {
                                console.log(`Re-running recipe for ${currCell.path} because:`);
                                deps.map(d => console.log(`\t${d.path}`));
                                yield currCell.runRecipe();
                                currCell.stat = yield getStat(currCell.path);
                                return currCell;
                            }
                            else {
                                console.log(`no need to re-run recipe for ${currCell.path}`);
                            }
                        }
                        return currCell;
                    });
                });
            });
        });
    }

    const styles = {
        bgWhite: { open: "\u001b[47m", close: "\u001b[49m" },
        bold: { open: "\u001b[1m", close: "\u001b[22m" },
        black: { open: "\u001b[30m", close: "\u001b[39m" }
    };
    const styleVariable = (v) => `${styles.bold.open}${styles.black.open}${styles.bgWhite.open}${v}${styles.bgWhite.close}${styles.black.close}${styles.bold.close}`;
    function oak_print(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const oakModule = yield parseOakfile(args.filename);
            const libSet = new Set(Object.keys(Library$1));
            console.log(`Oakfile at ${args.filename}:`);
            oakModule.cells.map(cell => {
                // TODO filename and recipe
                console.log(`${styleVariable(cell.id.name)} ${cell.references
                .map(ref => ref.name)
                .filter(refName => !libSet.has(refName))
                .join(",")}`);
            });
        });
    }

    var CommandLineParameter_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Identifies the kind of a CommandLineParameter.
     * @public
     */
    var CommandLineParameterKind;
    (function (CommandLineParameterKind) {
        /** Indicates a CommandLineChoiceParameter */
        CommandLineParameterKind[CommandLineParameterKind["Choice"] = 0] = "Choice";
        /** Indicates a CommandLineFlagParameter */
        CommandLineParameterKind[CommandLineParameterKind["Flag"] = 1] = "Flag";
        /** Indicates a CommandLineIntegerParameter */
        CommandLineParameterKind[CommandLineParameterKind["Integer"] = 2] = "Integer";
        /** Indicates a CommandLineStringParameter */
        CommandLineParameterKind[CommandLineParameterKind["String"] = 3] = "String";
        /** Indicates a CommandLineStringListParameter */
        CommandLineParameterKind[CommandLineParameterKind["StringList"] = 4] = "StringList";
    })(CommandLineParameterKind = exports.CommandLineParameterKind || (exports.CommandLineParameterKind = {}));
    /**
     * The base class for the various command-line parameter types.
     * @public
     */
    class CommandLineParameter {
        /** @internal */
        constructor(definition) {
            this.longName = definition.parameterLongName;
            this.shortName = definition.parameterShortName;
            this.description = definition.description;
            this.required = !!definition.required;
            this.environmentVariable = definition.environmentVariable;
            if (!CommandLineParameter._longNameRegExp.test(this.longName)) {
                throw new Error(`Invalid name: "${this.longName}". The parameter long name must be`
                    + ` lower-case and use dash delimiters (e.g. "--do-a-thing")`);
            }
            if (this.shortName) {
                if (!CommandLineParameter._shortNameRegExp.test(this.shortName)) {
                    throw new Error(`Invalid name: "${this.shortName}". The parameter short name must be`
                        + ` a dash followed by a single upper-case or lower-case letter (e.g. "-a")`);
                }
            }
            if (this.environmentVariable) {
                if (this.required) {
                    throw new Error(`An "environmentVariable" cannot be specified for "${this.longName}"`
                        + ` because it is a required parameter`);
                }
                if (!CommandLineParameter._environmentVariableRegExp.test(this.environmentVariable)) {
                    throw new Error(`Invalid environment variable name: "${this.environmentVariable}". The name must`
                        + ` consist only of upper-case letters, numbers, and underscores. It may not start with a number.`);
                }
            }
        }
        /**
         * Returns additional text used by the help formatter.
         * @internal
         */
        _getSupplementaryNotes(supplementaryNotes) {
            if (this.environmentVariable !== undefined) {
                supplementaryNotes.push('This parameter may alternatively specified via the ' + this.environmentVariable
                    + ' environment variable.');
            }
        }
        /**
         * Internal usage only.  Used to report unexpected output from the argparse library.
         */
        reportInvalidData(data) {
            throw new Error(`Unexpected data object for parameter "${this.longName}": `
                + JSON.stringify(data));
        }
        validateDefaultValue(hasDefaultValue) {
            if (this.required && hasDefaultValue) {
                // If a parameter is "required", then the user understands that they always need to
                // specify a value for this parameter (either via the command line or via an environment variable).
                // It would be confusing to allow a default value that sometimes allows the "required" parameter
                // to be omitted.  If you sometimes don't have a suitable default value, then the better approach
                // is to throw a custom error explaining why the parameter is required in that case.
                throw new Error(`A default value cannot be specified for "${this.longName}"`
                    + ` because it is a "required" parameter`);
            }
        }
    }
    // Example: "--do-something"
    CommandLineParameter._longNameRegExp = /^-(-[a-z0-9]+)+$/;
    // Example: "-d"
    CommandLineParameter._shortNameRegExp = /^-[a-zA-Z]$/;
    // "Environment variable names used by the utilities in the Shell and Utilities volume of
    // IEEE Std 1003.1-2001 consist solely of uppercase letters, digits, and the '_' (underscore)
    // from the characters defined in Portable Character Set and do not begin with a digit."
    // Example: "THE_SETTING"
    CommandLineParameter._environmentVariableRegExp = /^[A-Z_][A-Z0-9_]*$/;
    exports.CommandLineParameter = CommandLineParameter;
    /**
     * The common base class for parameters types that receive an argument.
     *
     * @remarks
     * An argument is an accompanying command-line token, such as "123" in the
     * example "--max-count 123".
     * @public
     */
    class CommandLineParameterWithArgument extends CommandLineParameter {
        /** @internal */
        constructor(definition) {
            super(definition);
            if (definition.argumentName === '') {
                throw new Error('The argument name cannot be an empty string. (For the default name, specify undefined.)');
            }
            if (definition.argumentName.toUpperCase() !== definition.argumentName) {
                throw new Error(`Invalid name: "${definition.argumentName}". The argument name must be all upper case.`);
            }
            const match = definition.argumentName.match(CommandLineParameterWithArgument._invalidArgumentNameRegExp);
            if (match) {
                throw new Error(`The argument name "${definition.argumentName}" contains an invalid character "${match[0]}".`
                    + ` Only upper-case letters, numbers, and underscores are allowed.`);
            }
            this.argumentName = definition.argumentName;
        }
    }
    // Matches the first character that *isn't* part of a valid upper-case argument name such as "URL_2"
    CommandLineParameterWithArgument._invalidArgumentNameRegExp = /[^A-Z_0-9]/;
    exports.CommandLineParameterWithArgument = CommandLineParameterWithArgument;
    /**
     * The data type returned by {@link CommandLineParameterProvider.defineChoiceParameter}.
     * @public
     */
    class CommandLineChoiceParameter extends CommandLineParameter {
        /** @internal */
        constructor(definition) {
            super(definition);
            this._value = undefined;
            if (definition.alternatives.length <= 1) {
                throw new Error(`When defining a choice parameter, the alternatives list must contain at least one value.`);
            }
            if (definition.defaultValue && definition.alternatives.indexOf(definition.defaultValue) === -1) {
                throw new Error(`The specified default value "${definition.defaultValue}"`
                    + ` is not one of the available options: ${definition.alternatives.toString()}`);
            }
            this.alternatives = definition.alternatives;
            this.defaultValue = definition.defaultValue;
            this.validateDefaultValue(!!this.defaultValue);
        }
        /** {@inheritDoc CommandLineParameter.kind} */
        get kind() {
            return CommandLineParameterKind.Choice;
        }
        /**
         * {@inheritDoc CommandLineParameter._setValue}
         * @internal
         */
        // tslint:disable-next-line:no-any
        _setValue(data) {
            if (data !== null && data !== undefined) {
                if (typeof data !== 'string') {
                    this.reportInvalidData(data);
                }
                this._value = data;
                return;
            }
            if (this.environmentVariable !== undefined) {
                // Try reading the environment variable
                const environmentValue = process.env[this.environmentVariable];
                if (environmentValue !== undefined && environmentValue !== '') {
                    if (this.alternatives.indexOf(environmentValue) < 0) {
                        const choices = '"' + this.alternatives.join('", "') + '"';
                        throw new Error(`Invalid value "${environmentValue}" for the environment variable`
                            + ` ${this.environmentVariable}.  Valid choices are: ${choices}`);
                    }
                    this._value = environmentValue;
                    return;
                }
            }
            if (this.defaultValue !== undefined) {
                this._value = this.defaultValue;
                return;
            }
            this._value = undefined;
        }
        /**
         * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
         * @internal
         */
        _getSupplementaryNotes(supplementaryNotes) {
            super._getSupplementaryNotes(supplementaryNotes);
            if (this.defaultValue !== undefined) {
                supplementaryNotes.push(`The default value is "${this.defaultValue}".`);
            }
        }
        /**
         * Returns the argument value for a choice parameter that was parsed from the command line.
         *
         * @remarks
         * The return value will be `undefined` if the command-line has not been parsed yet,
         * or if the parameter was omitted and has no default value.
         */
        get value() {
            return this._value;
        }
        /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
        appendToArgList(argList) {
            if (this.value !== undefined) {
                argList.push(this.longName);
                argList.push(this.value);
            }
        }
    }
    exports.CommandLineChoiceParameter = CommandLineChoiceParameter;
    /**
     * The data type returned by {@link CommandLineParameterProvider.defineFlagParameter}.
     * @public
     */
    class CommandLineFlagParameter extends CommandLineParameter {
        /** @internal */
        constructor(definition) {
            super(definition);
            this._value = false;
        }
        /** {@inheritDoc CommandLineParameter.kind} */
        get kind() {
            return CommandLineParameterKind.Flag;
        }
        /**
         * {@inheritDoc CommandLineParameter._setValue}
         * @internal
         */
        // tslint:disable-next-line:no-any
        _setValue(data) {
            if (data !== null && data !== undefined) {
                if (typeof data !== 'boolean') {
                    this.reportInvalidData(data);
                }
                this._value = data;
                return;
            }
            if (this.environmentVariable !== undefined) {
                // Try reading the environment variable
                const environmentValue = process.env[this.environmentVariable];
                if (environmentValue !== undefined && environmentValue !== '') {
                    if (environmentValue !== '0' && environmentValue !== '1') {
                        throw new Error(`Invalid value "${environmentValue}" for the environment variable`
                            + ` ${this.environmentVariable}.  Valid choices are 0 or 1.`);
                    }
                    this._value = environmentValue === '1';
                    return;
                }
            }
            this._value = false;
        }
        /**
         * Returns a boolean indicating whether the parameter was included in the command line.
         *
         * @remarks
         * The return value will be false if the command-line has not been parsed yet,
         * or if the flag was not used.
         */
        get value() {
            return this._value;
        }
        /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
        appendToArgList(argList) {
            if (this.value) {
                argList.push(this.longName);
            }
        }
    }
    exports.CommandLineFlagParameter = CommandLineFlagParameter;
    /**
     * The data type returned by {@link CommandLineParameterProvider.defineIntegerParameter}.
     * @public
     */
    class CommandLineIntegerParameter extends CommandLineParameterWithArgument {
        /** @internal */
        constructor(definition) {
            super(definition);
            this._value = undefined;
            this.defaultValue = definition.defaultValue;
            this.validateDefaultValue(!!this.defaultValue);
        }
        /** {@inheritDoc CommandLineParameter.kind} */
        get kind() {
            return CommandLineParameterKind.Integer;
        }
        /**
         * {@inheritDoc CommandLineParameter._setValue}
         * @internal
         */
        // tslint:disable-next-line:no-any
        _setValue(data) {
            if (data !== null && data !== undefined) {
                if (typeof data !== 'number') {
                    this.reportInvalidData(data);
                }
                this._value = data;
                return;
            }
            if (this.environmentVariable !== undefined) {
                // Try reading the environment variable
                const environmentValue = process.env[this.environmentVariable];
                if (environmentValue !== undefined && environmentValue !== '') {
                    const parsed = parseInt(environmentValue, 10);
                    if (isNaN(parsed) || environmentValue.indexOf('.') >= 0) {
                        throw new Error(`Invalid value "${environmentValue}" for the environment variable`
                            + ` ${this.environmentVariable}.  It must be an integer value.`);
                    }
                    this._value = parsed;
                    return;
                }
            }
            if (this.defaultValue !== undefined) {
                this._value = this.defaultValue;
                return;
            }
            this._value = undefined;
        }
        /**
         * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
         * @internal
         */
        _getSupplementaryNotes(supplementaryNotes) {
            super._getSupplementaryNotes(supplementaryNotes);
            if (this.defaultValue !== undefined) {
                supplementaryNotes.push(`The default value is ${this.defaultValue}.`);
            }
        }
        /**
         * Returns the argument value for an integer parameter that was parsed from the command line.
         *
         * @remarks
         * The return value will be undefined if the command-line has not been parsed yet,
         * or if the parameter was omitted and has no default value.
         */
        get value() {
            return this._value;
        }
        /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
        appendToArgList(argList) {
            if (this.value !== undefined) {
                argList.push(this.longName);
                argList.push(this.value.toString());
            }
        }
    }
    exports.CommandLineIntegerParameter = CommandLineIntegerParameter;
    /**
     * The data type returned by {@link CommandLineParameterProvider.defineStringParameter}.
     * @public
     */
    class CommandLineStringParameter extends CommandLineParameterWithArgument {
        /** @internal */
        constructor(definition) {
            super(definition);
            this._value = undefined;
            this.defaultValue = definition.defaultValue;
            this.validateDefaultValue(!!this.defaultValue);
        }
        /** {@inheritDoc CommandLineParameter.kind} */
        get kind() {
            return CommandLineParameterKind.String;
        }
        /**
         * {@inheritDoc CommandLineParameter._setValue}
         * @internal
         */
        // tslint:disable-next-line:no-any
        _setValue(data) {
            if (data !== null && data !== undefined) {
                if (typeof data !== 'string') {
                    this.reportInvalidData(data);
                }
                this._value = data;
                return;
            }
            if (this.environmentVariable !== undefined) {
                // Try reading the environment variable
                const environmentValue = process.env[this.environmentVariable];
                if (environmentValue !== undefined) {
                    // NOTE: If the environment variable is defined as an empty string,
                    // here we will accept the empty string as our value.  (For number/flag we don't do that.)
                    this._value = environmentValue;
                    return;
                }
            }
            if (this.defaultValue !== undefined) {
                this._value = this.defaultValue;
                return;
            }
            this._value = undefined;
        }
        /**
         * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
         * @internal
         */
        _getSupplementaryNotes(supplementaryNotes) {
            super._getSupplementaryNotes(supplementaryNotes);
            if (this.defaultValue !== undefined) {
                if (this.defaultValue.length < 160) {
                    supplementaryNotes.push(`The default value is ${JSON.stringify(this.defaultValue)}.`);
                }
            }
        }
        /**
         * Returns the argument value for a string parameter that was parsed from the command line.
         *
         * @remarks
         * The return value will be undefined if the command-line has not been parsed yet,
         * or if the parameter was omitted and has no default value.
         */
        get value() {
            return this._value;
        }
        /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
        appendToArgList(argList) {
            if (this.value !== undefined) {
                argList.push(this.longName);
                argList.push(this.value);
            }
        }
    }
    exports.CommandLineStringParameter = CommandLineStringParameter;
    /**
     * The data type returned by {@link CommandLineParameterProvider.defineStringListParameter}.
     * @public
     */
    class CommandLineStringListParameter extends CommandLineParameterWithArgument {
        /** @internal */
        constructor(definition) {
            super(definition);
            this._values = [];
        }
        /** {@inheritDoc CommandLineParameter.kind} */
        get kind() {
            return CommandLineParameterKind.StringList;
        }
        /**
         * {@inheritDoc CommandLineParameter._setValue}
         * @internal
         */
        // tslint:disable-next-line:no-any
        _setValue(data) {
            if (data !== null && data !== undefined) {
                if (!Array.isArray(data)) {
                    this.reportInvalidData(data);
                }
                for (const arrayItem of data) {
                    if (typeof (arrayItem) !== 'string') {
                        this.reportInvalidData(data);
                    }
                }
                this._values = data;
                return;
            }
            if (this.environmentVariable !== undefined) {
                // Try reading the environment variable
                const environmentValue = process.env[this.environmentVariable];
                if (environmentValue !== undefined) {
                    // NOTE: If the environment variable is defined as an empty string,
                    // here we will accept the empty string as our value.  (For number/flag we don't do that.)
                    // In the current implementation, the environment variable for a "string list" can only
                    // store a single item.  If we wanted to allow multiple items (and still have a conventional-seeming
                    // environment), we would ask the caller to provide an appropriate delimiter.  Getting involved
                    // with escaping here seems unwise, since there are so many shell escaping mechanisms that could
                    // potentially confuse the experience.
                    this._values = [environmentValue];
                    return;
                }
            }
            // (No default value for string lists)
            this._values = [];
        }
        /**
         * Returns the string arguments for a string list parameter that was parsed from the command line.
         *
         * @remarks
         * The array will be empty if the command-line has not been parsed yet,
         * or if the parameter was omitted and has no default value.
         */
        get values() {
            return this._values;
        }
        /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
        appendToArgList(argList) {
            if (this.values.length > 0) {
                for (const value of this.values) {
                    argList.push(this.longName);
                    argList.push(value);
                }
            }
        }
    }
    exports.CommandLineStringListParameter = CommandLineStringListParameter;

    });

    unwrapExports(CommandLineParameter_1);
    var CommandLineParameter_2 = CommandLineParameter_1.CommandLineParameterKind;
    var CommandLineParameter_3 = CommandLineParameter_1.CommandLineParameter;
    var CommandLineParameter_4 = CommandLineParameter_1.CommandLineParameterWithArgument;
    var CommandLineParameter_5 = CommandLineParameter_1.CommandLineChoiceParameter;
    var CommandLineParameter_6 = CommandLineParameter_1.CommandLineFlagParameter;
    var CommandLineParameter_7 = CommandLineParameter_1.CommandLineIntegerParameter;
    var CommandLineParameter_8 = CommandLineParameter_1.CommandLineStringParameter;
    var CommandLineParameter_9 = CommandLineParameter_1.CommandLineStringListParameter;

    var CommandLineParameterProvider_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * This is the common base class for CommandLineAction and CommandLineParser
     * that provides functionality for defining command-line parameters.
     *
     * @public
     */
    class CommandLineParameterProvider {
        /** @internal */
        // Third party code should not inherit subclasses or call this constructor
        constructor() {
            this._parameters = [];
            this._parametersByLongName = new Map();
        }
        /**
         * Returns a collection of the parameters that were defined for this object.
         */
        get parameters() {
            return this._parameters;
        }
        /**
         * Defines a command-line parameter whose value must be a string from a fixed set of
         * allowable choices (similar to an enum).
         *
         * @remarks
         * Example:  example-tool --log-level warn
         */
        defineChoiceParameter(definition) {
            const parameter = new CommandLineParameter_1.CommandLineChoiceParameter(definition);
            this._defineParameter(parameter);
            return parameter;
        }
        /**
         * Returns the CommandLineChoiceParameter with the specified long name.
         * @remarks
         * This method throws an exception if the parameter is not defined.
         */
        getChoiceParameter(parameterLongName) {
            return this._getParameter(parameterLongName, CommandLineParameter_1.CommandLineParameterKind.Choice);
        }
        /**
         * Defines a command-line switch whose boolean value is true if the switch is provided,
         * and false otherwise.
         *
         * @remarks
         * Example:  example-tool --debug
         */
        defineFlagParameter(definition) {
            const parameter = new CommandLineParameter_1.CommandLineFlagParameter(definition);
            this._defineParameter(parameter);
            return parameter;
        }
        /**
         * Returns the CommandLineFlagParameter with the specified long name.
         * @remarks
         * This method throws an exception if the parameter is not defined.
         */
        getFlagParameter(parameterLongName) {
            return this._getParameter(parameterLongName, CommandLineParameter_1.CommandLineParameterKind.Flag);
        }
        /**
         * Defines a command-line parameter whose value is an integer.
         *
         * @remarks
         * Example:  example-tool --max-attempts 5
         */
        defineIntegerParameter(definition) {
            const parameter = new CommandLineParameter_1.CommandLineIntegerParameter(definition);
            this._defineParameter(parameter);
            return parameter;
        }
        /**
         * Returns the CommandLineIntegerParameter with the specified long name.
         * @remarks
         * This method throws an exception if the parameter is not defined.
         */
        getIntegerParameter(parameterLongName) {
            return this._getParameter(parameterLongName, CommandLineParameter_1.CommandLineParameterKind.Integer);
        }
        /**
         * Defines a command-line parameter whose value is a single text string.
         *
         * @remarks
         * Example:  example-tool --message "Hello, world!"
         */
        defineStringParameter(definition) {
            const parameter = new CommandLineParameter_1.CommandLineStringParameter(definition);
            this._defineParameter(parameter);
            return parameter;
        }
        /**
         * Returns the CommandLineStringParameter with the specified long name.
         * @remarks
         * This method throws an exception if the parameter is not defined.
         */
        getStringParameter(parameterLongName) {
            return this._getParameter(parameterLongName, CommandLineParameter_1.CommandLineParameterKind.String);
        }
        /**
         * Defines a command-line parameter whose value is one or more text strings.
         *
         * @remarks
         * Example:  example-tool --add file1.txt --add file2.txt --add file3.txt
         */
        defineStringListParameter(definition) {
            const parameter = new CommandLineParameter_1.CommandLineStringListParameter(definition);
            this._defineParameter(parameter);
            return parameter;
        }
        /**
         * Returns the CommandLineStringListParameter with the specified long name.
         * @remarks
         * This method throws an exception if the parameter is not defined.
         */
        getStringListParameter(parameterLongName) {
            return this._getParameter(parameterLongName, CommandLineParameter_1.CommandLineParameterKind.StringList);
        }
        /**
         * Generates the command-line help text.
         */
        renderHelpText() {
            return this._getArgumentParser().formatHelp();
        }
        /** @internal */
        _processParsedData(data) {
            // Fill in the values for the parameters
            for (const parameter of this._parameters) {
                const value = data[parameter._parserKey]; // tslint:disable-line:no-any
                parameter._setValue(value);
            }
        }
        _generateKey() {
            return 'key_' + (CommandLineParameterProvider._keyCounter++).toString();
        }
        _getParameter(parameterLongName, expectedKind) {
            const parameter = this._parametersByLongName.get(parameterLongName);
            if (!parameter) {
                throw new Error(`The parameter "${parameterLongName}" is not defined`);
            }
            if (parameter.kind !== expectedKind) {
                throw new Error(`The parameter "${parameterLongName}" is of type "${CommandLineParameter_1.CommandLineParameterKind[parameter.kind]}"`
                    + ` whereas the caller was expecting "${CommandLineParameter_1.CommandLineParameterKind[expectedKind]}".`);
            }
            return parameter;
        }
        _defineParameter(parameter) {
            const names = [];
            if (parameter.shortName) {
                names.push(parameter.shortName);
            }
            names.push(parameter.longName);
            parameter._parserKey = this._generateKey();
            let finalDescription = parameter.description;
            const supplementaryNotes = [];
            parameter._getSupplementaryNotes(supplementaryNotes);
            if (supplementaryNotes.length > 0) {
                // If they left the period off the end of their sentence, then add one.
                if (finalDescription.match(/[a-z0-9]\s*$/i)) {
                    finalDescription = finalDescription.trimRight() + '.';
                }
                // Append the supplementary text
                finalDescription += ' ' + supplementaryNotes.join(' ');
            }
            // NOTE: Our "environmentVariable" feature takes precedence over argparse's "defaultValue",
            // so we have to reimplement that feature.
            const argparseOptions = {
                help: finalDescription,
                dest: parameter._parserKey,
                metavar: parameter.argumentName || undefined,
                required: parameter.required
            };
            switch (parameter.kind) {
                case CommandLineParameter_1.CommandLineParameterKind.Choice:
                    const choiceParameter = parameter;
                    argparseOptions.choices = choiceParameter.alternatives;
                    break;
                case CommandLineParameter_1.CommandLineParameterKind.Flag:
                    argparseOptions.action = 'storeTrue';
                    break;
                case CommandLineParameter_1.CommandLineParameterKind.Integer:
                    argparseOptions.type = 'int';
                    break;
                case CommandLineParameter_1.CommandLineParameterKind.String:
                    break;
                case CommandLineParameter_1.CommandLineParameterKind.StringList:
                    argparseOptions.action = 'append';
                    break;
            }
            this._getArgumentParser().addArgument(names, argparseOptions);
            this._parameters.push(parameter);
            this._parametersByLongName.set(parameter.longName, parameter);
        }
    }
    CommandLineParameterProvider._keyCounter = 0;
    exports.CommandLineParameterProvider = CommandLineParameterProvider;

    });

    unwrapExports(CommandLineParameterProvider_1);
    var CommandLineParameterProvider_2 = CommandLineParameterProvider_1.CommandLineParameterProvider;

    var CommandLineAction_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Represents a sub-command that is part of the CommandLineParser command line.
     * Applications should create subclasses of CommandLineAction corresponding to
     * each action that they want to expose.
     *
     * The action name should be comprised of lower case words separated by hyphens
     * or colons. The name should include an English verb (e.g. "deploy"). Use a
     * hyphen to separate words (e.g. "upload-docs"). A group of related commands
     * can be prefixed with a colon (e.g. "docs:generate", "docs:deploy",
     * "docs:serve", etc).
     *
     * @public
     */
    class CommandLineAction extends CommandLineParameterProvider_1.CommandLineParameterProvider {
        constructor(options) {
            super();
            if (!CommandLineAction._actionNameRegExp.test(options.actionName)) {
                throw new Error(`Invalid action name "${options.actionName}". `
                    + `The name must be comprised of lower-case words optionally separated by hyphens or colons.`);
            }
            this.actionName = options.actionName;
            this.summary = options.summary;
            this.documentation = options.documentation;
            this._argumentParser = undefined;
        }
        /**
         * This is called internally by CommandLineParser.addAction()
         * @internal
         */
        _buildParser(actionsSubParser) {
            this._argumentParser = actionsSubParser.addParser(this.actionName, {
                help: this.summary,
                description: this.documentation
            });
            this.onDefineParameters();
        }
        /**
         * This is called internally by CommandLineParser.execute()
         * @internal
         */
        _processParsedData(data) {
            super._processParsedData(data);
        }
        /**
         * Invoked by CommandLineParser.onExecute().
         * @internal
         */
        _execute() {
            return this.onExecute();
        }
        /**
         * {@inheritDoc CommandLineParameterProvider._getArgumentParser}
         * @internal
         */
        _getArgumentParser() {
            if (!this._argumentParser) {
                // We will improve this in the future
                throw new Error('The CommandLineAction must be added to a CommandLineParser before it can be used');
            }
            return this._argumentParser;
        }
    }
    // Example: "do-something"
    CommandLineAction._actionNameRegExp = /^[a-z]+([-:][a-z]+)*$/;
    exports.CommandLineAction = CommandLineAction;

    });

    unwrapExports(CommandLineAction_1);
    var CommandLineAction_2 = CommandLineAction_1.CommandLineAction;

    var sprintf = createCommonjsModule(function (module, exports) {
    (function(window) {
        var re = {
            not_string: /[^s]/,
            number: /[diefg]/,
            json: /[j]/,
            not_json: /[^j]/,
            text: /^[^\x25]+/,
            modulo: /^\x25{2}/,
            placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
            key: /^([a-z_][a-z_\d]*)/i,
            key_access: /^\.([a-z_][a-z_\d]*)/i,
            index_access: /^\[(\d+)\]/,
            sign: /^[\+\-]/
        };

        function sprintf() {
            var key = arguments[0], cache = sprintf.cache;
            if (!(cache[key] && cache.hasOwnProperty(key))) {
                cache[key] = sprintf.parse(key);
            }
            return sprintf.format.call(null, cache[key], arguments)
        }

        sprintf.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = "";
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === "string") {
                    output[output.length] = parse_tree[i];
                }
                else if (node_type === "array") {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }

                    if (get_type(arg) == "function") {
                        arg = arg();
                    }

                    if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                        throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                    }

                    if (re.number.test(match[8])) {
                        is_positive = arg >= 0;
                    }

                    switch (match[8]) {
                        case "b":
                            arg = arg.toString(2);
                        break
                        case "c":
                            arg = String.fromCharCode(arg);
                        break
                        case "d":
                        case "i":
                            arg = parseInt(arg, 10);
                        break
                        case "j":
                            arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                        break
                        case "e":
                            arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                        break
                        case "f":
                            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                        break
                        case "g":
                            arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);
                        break
                        case "o":
                            arg = arg.toString(8);
                        break
                        case "s":
                            arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg);
                        break
                        case "u":
                            arg = arg >>> 0;
                        break
                        case "x":
                            arg = arg.toString(16);
                        break
                        case "X":
                            arg = arg.toString(16).toUpperCase();
                        break
                    }
                    if (re.json.test(match[8])) {
                        output[output.length] = arg;
                    }
                    else {
                        if (re.number.test(match[8]) && (!is_positive || match[3])) {
                            sign = is_positive ? "+" : "-";
                            arg = arg.toString().replace(re.sign, "");
                        }
                        else {
                            sign = "";
                        }
                        pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " ";
                        pad_length = match[6] - (sign + arg).length;
                        pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : "";
                        output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg);
                    }
                }
            }
            return output.join("")
        };

        sprintf.cache = {};

        sprintf.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = re.text.exec(_fmt)) !== null) {
                    parse_tree[parse_tree.length] = match[0];
                }
                else if ((match = re.modulo.exec(_fmt)) !== null) {
                    parse_tree[parse_tree.length] = "%";
                }
                else if ((match = re.placeholder.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = re.key.exec(replacement_field)) !== null) {
                            field_list[field_list.length] = field_match[1];
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                    field_list[field_list.length] = field_match[1];
                                }
                                else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                    field_list[field_list.length] = field_match[1];
                                }
                                else {
                                    throw new SyntaxError("[sprintf] failed to parse named argument key")
                                }
                            }
                        }
                        else {
                            throw new SyntaxError("[sprintf] failed to parse named argument key")
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                    }
                    parse_tree[parse_tree.length] = match;
                }
                else {
                    throw new SyntaxError("[sprintf] unexpected placeholder")
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree
        };

        var vsprintf = function(fmt, argv, _argv) {
            _argv = (argv || []).slice(0);
            _argv.splice(0, 0, fmt);
            return sprintf.apply(null, _argv)
        };

        /**
         * helpers
         */
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
        }

        function str_repeat(input, multiplier) {
            return Array(multiplier + 1).join(input)
        }

        /**
         * export to either browser or node.js
         */
        {
            exports.sprintf = sprintf;
            exports.vsprintf = vsprintf;
        }
    })();
    });
    var sprintf_1 = sprintf.sprintf;
    var sprintf_2 = sprintf.vsprintf;

    //

    var EOL = '\n';

    var SUPPRESS = '==SUPPRESS==';

    var OPTIONAL = '?';

    var ZERO_OR_MORE = '*';

    var ONE_OR_MORE = '+';

    var PARSER = 'A...';

    var REMAINDER = '...';

    var _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';

    var _const = {
    	EOL: EOL,
    	SUPPRESS: SUPPRESS,
    	OPTIONAL: OPTIONAL,
    	ZERO_OR_MORE: ZERO_OR_MORE,
    	ONE_OR_MORE: ONE_OR_MORE,
    	PARSER: PARSER,
    	REMAINDER: REMAINDER,
    	_UNRECOGNIZED_ARGS_ATTR: _UNRECOGNIZED_ARGS_ATTR
    };

    var repeat = function (str, num) {
      var result = '';
      for (var i = 0; i < num; i++) { result += str; }
      return result;
    };

    var arrayEqual = function (a, b) {
      if (a.length !== b.length) { return false; }
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) { return false; }
      }
      return true;
    };

    var trimChars = function (str, chars) {
      var start = 0;
      var end = str.length - 1;
      while (chars.indexOf(str.charAt(start)) >= 0) { start++; }
      while (chars.indexOf(str.charAt(end)) >= 0) { end--; }
      return str.slice(start, end + 1);
    };

    var capitalize = function (str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    };

    var arrayUnion = function () {
      var result = [];
      for (var i = 0, values = {}; i < arguments.length; i++) {
        var arr = arguments[i];
        for (var j = 0; j < arr.length; j++) {
          if (!values[arr[j]]) {
            values[arr[j]] = true;
            result.push(arr[j]);
          }
        }
      }
      return result;
    };

    function has$1(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    var has_1 = has$1;

    var extend = function (dest, src) {
      for (var i in src) {
        if (has$1(src, i)) { dest[i] = src[i]; }
      }
    };

    var trimEnd = function (str) {
      return str.replace(/\s+$/g, '');
    };

    var utils = {
    	repeat: repeat,
    	arrayEqual: arrayEqual,
    	trimChars: trimChars,
    	capitalize: capitalize,
    	arrayUnion: arrayUnion,
    	has: has_1,
    	extend: extend,
    	trimEnd: trimEnd
    };

    var action = createCommonjsModule(function (module) {


    // Constants



    /**
     * new Action(options)
     *
     * Base class for all actions. Used only for inherits
     *
     *
     * ##### Options:
     *
     * - `optionStrings`  A list of command-line option strings for the action.
     * - `dest`  Attribute to hold the created object(s)
     * - `nargs`  The number of command-line arguments that should be consumed.
     * By default, one argument will be consumed and a single value will be
     * produced.
     * - `constant`  Default value for an action with no value.
     * - `defaultValue`  The value to be produced if the option is not specified.
     * - `type`  Cast to 'string'|'int'|'float'|'complex'|function (string). If
     * None, 'string'.
     * - `choices`  The choices available.
     * - `required`  True if the action must always be specified at the command
     * line.
     * - `help`  The help describing the argument.
     * - `metavar`  The name to be used for the option's argument with the help
     * string. If None, the 'dest' value will be used as the name.
     *
     * ##### nargs supported values:
     *
     * - `N` (an integer) consumes N arguments (and produces a list)
     * - `?`  consumes zero or one arguments
     * - `*` consumes zero or more arguments (and produces a list)
     * - `+` consumes one or more arguments (and produces a list)
     *
     * Note: that the difference between the default and nargs=1 is that with the
     * default, a single value will be produced, while with nargs=1, a list
     * containing a single value will be produced.
     **/
    var Action = module.exports = function Action(options) {
      options = options || {};
      this.optionStrings = options.optionStrings || [];
      this.dest = options.dest;
      this.nargs = typeof options.nargs !== 'undefined' ? options.nargs : null;
      this.constant = typeof options.constant !== 'undefined' ? options.constant : null;
      this.defaultValue = options.defaultValue;
      this.type = typeof options.type !== 'undefined' ? options.type : null;
      this.choices = typeof options.choices !== 'undefined' ? options.choices : null;
      this.required = typeof options.required !== 'undefined' ? options.required : false;
      this.help = typeof options.help !== 'undefined' ? options.help : null;
      this.metavar = typeof options.metavar !== 'undefined' ? options.metavar : null;

      if (!(this.optionStrings instanceof Array)) {
        throw new Error('optionStrings should be an array');
      }
      if (typeof this.required !== 'undefined' && typeof this.required !== 'boolean') {
        throw new Error('required should be a boolean');
      }
    };

    /**
     * Action#getName -> String
     *
     * Tells action name
     **/
    Action.prototype.getName = function () {
      if (this.optionStrings.length > 0) {
        return this.optionStrings.join('/');
      } else if (this.metavar !== null && this.metavar !== _const.SUPPRESS) {
        return this.metavar;
      } else if (typeof this.dest !== 'undefined' && this.dest !== _const.SUPPRESS) {
        return this.dest;
      }
      return null;
    };

    /**
     * Action#isOptional -> Boolean
     *
     * Return true if optional
     **/
    Action.prototype.isOptional = function () {
      return !this.isPositional();
    };

    /**
     * Action#isPositional -> Boolean
     *
     * Return true if positional
     **/
    Action.prototype.isPositional = function () {
      return (this.optionStrings.length === 0);
    };

    /**
     * Action#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Should be implemented in inherited classes
     *
     * ##### Example
     *
     *      ActionCount.prototype.call = function (parser, namespace, values, optionString) {
     *        namespace.set(this.dest, (namespace[this.dest] || 0) + 1);
     *      };
     *
     **/
    Action.prototype.call = function () {
      throw new Error('.call() not defined');// Not Implemented error
    };
    });

    var help = createCommonjsModule(function (module) {





    // Constants


    /*:nodoc:*
     * new ActionHelp(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionHelp = module.exports = function ActionHelp(options) {
      options = options || {};
      if (options.defaultValue !== null) {
        options.defaultValue = options.defaultValue;
      } else {
        options.defaultValue = _const.SUPPRESS;
      }
      options.dest = (options.dest !== null ? options.dest : _const.SUPPRESS);
      options.nargs = 0;
      action.call(this, options);

    };
    util.inherits(ActionHelp, action);

    /*:nodoc:*
     * ActionHelp#call(parser, namespace, values, optionString)
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Print help and exit
     **/
    ActionHelp.prototype.call = function (parser) {
      parser.printHelp();
      parser.exit();
    };
    });

    var append = createCommonjsModule(function (module) {





    // Constants


    /*:nodoc:*
     * new ActionAppend(options)
     * - options (object): options hash see [[Action.new]]
     *
     * Note: options.nargs should be optional for constants
     * and more then zero for other
     **/
    var ActionAppend = module.exports = function ActionAppend(options) {
      options = options || {};
      if (this.nargs <= 0) {
        throw new Error('nargs for append actions must be > 0; if arg ' +
            'strings are not supplying the value to append, ' +
            'the append const action may be more appropriate');
      }
      if (!!this.constant && this.nargs !== _const.OPTIONAL) {
        throw new Error('nargs must be OPTIONAL to supply const');
      }
      action.call(this, options);
    };
    util.inherits(ActionAppend, action);

    /*:nodoc:*
     * ActionAppend#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Save result in namespace object
     **/
    ActionAppend.prototype.call = function (parser, namespace, values) {
      var items = (namespace[this.dest] || []).slice();
      items.push(values);
      namespace.set(this.dest, items);
    };
    });

    var constant$2 = createCommonjsModule(function (module) {





    /*:nodoc:*
     * new ActionAppendConstant(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionAppendConstant = module.exports = function ActionAppendConstant(options) {
      options = options || {};
      options.nargs = 0;
      if (typeof options.constant === 'undefined') {
        throw new Error('constant option is required for appendAction');
      }
      action.call(this, options);
    };
    util.inherits(ActionAppendConstant, action);

    /*:nodoc:*
     * ActionAppendConstant#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Save result in namespace object
     **/
    ActionAppendConstant.prototype.call = function (parser, namespace) {
      var items = [].concat(namespace[this.dest] || []);
      items.push(this.constant);
      namespace.set(this.dest, items);
    };
    });

    var count$1 = createCommonjsModule(function (module) {





    /*:nodoc:*
     * new ActionCount(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionCount = module.exports = function ActionCount(options) {
      options = options || {};
      options.nargs = 0;

      action.call(this, options);
    };
    util.inherits(ActionCount, action);

    /*:nodoc:*
     * ActionCount#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Save result in namespace object
     **/
    ActionCount.prototype.call = function (parser, namespace) {
      namespace.set(this.dest, (namespace[this.dest] || 0) + 1);
    };
    });

    var store = createCommonjsModule(function (module) {





    // Constants



    /*:nodoc:*
     * new ActionStore(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionStore = module.exports = function ActionStore(options) {
      options = options || {};
      if (this.nargs <= 0) {
        throw new Error('nargs for store actions must be > 0; if you ' +
            'have nothing to store, actions such as store ' +
            'true or store const may be more appropriate');

      }
      if (typeof this.constant !== 'undefined' && this.nargs !== _const.OPTIONAL) {
        throw new Error('nargs must be OPTIONAL to supply const');
      }
      action.call(this, options);
    };
    util.inherits(ActionStore, action);

    /*:nodoc:*
     * ActionStore#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Save result in namespace object
     **/
    ActionStore.prototype.call = function (parser, namespace, values) {
      namespace.set(this.dest, values);
    };
    });

    var constant$3 = createCommonjsModule(function (module) {





    /*:nodoc:*
     * new ActionStoreConstant(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionStoreConstant = module.exports = function ActionStoreConstant(options) {
      options = options || {};
      options.nargs = 0;
      if (typeof options.constant === 'undefined') {
        throw new Error('constant option is required for storeAction');
      }
      action.call(this, options);
    };
    util.inherits(ActionStoreConstant, action);

    /*:nodoc:*
     * ActionStoreConstant#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Save result in namespace object
     **/
    ActionStoreConstant.prototype.call = function (parser, namespace) {
      namespace.set(this.dest, this.constant);
    };
    });

    var _true = createCommonjsModule(function (module) {





    /*:nodoc:*
     * new ActionStoreTrue(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionStoreTrue = module.exports = function ActionStoreTrue(options) {
      options = options || {};
      options.constant = true;
      options.defaultValue = options.defaultValue !== null ? options.defaultValue : false;
      constant$3.call(this, options);
    };
    util.inherits(ActionStoreTrue, constant$3);
    });

    var _false = createCommonjsModule(function (module) {





    /*:nodoc:*
     * new ActionStoreFalse(options)
     * - options (object): hash of options see [[Action.new]]
     *
     **/
    var ActionStoreFalse = module.exports = function ActionStoreFalse(options) {
      options = options || {};
      options.constant = false;
      options.defaultValue = options.defaultValue !== null ? options.defaultValue : true;
      constant$3.call(this, options);
    };
    util.inherits(ActionStoreFalse, constant$3);
    });

    var version$1 = createCommonjsModule(function (module) {





    //
    // Constants
    //


    /*:nodoc:*
     * new ActionVersion(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    var ActionVersion = module.exports = function ActionVersion(options) {
      options = options || {};
      options.defaultValue = (options.defaultValue ? options.defaultValue : _const.SUPPRESS);
      options.dest = (options.dest || _const.SUPPRESS);
      options.nargs = 0;
      this.version = options.version;
      action.call(this, options);
    };
    util.inherits(ActionVersion, action);

    /*:nodoc:*
     * ActionVersion#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Print version and exit
     **/
    ActionVersion.prototype.call = function (parser) {
      var version = this.version || parser.version;
      var formatter = parser._getFormatter();
      formatter.addText(version);
      parser.exit(0, formatter.formatHelp());
    };
    });

    var format  = util.format;


    var ERR_CODE = 'ARGError';

    /*:nodoc:*
     * argumentError(argument, message) -> TypeError
     * - argument (Object): action with broken argument
     * - message (String): error message
     *
     * Error format helper. An error from creating or using an argument
     * (optional or positional). The string value of this exception
     * is the message, augmented with information
     * about the argument that caused it.
     *
     * #####Example
     *
     *      var argumentErrorHelper = require('./argument/error');
     *      if (conflictOptionals.length > 0) {
     *        throw argumentErrorHelper(
     *          action,
     *          format('Conflicting option string(s): %s', conflictOptionals.join(', '))
     *        );
     *      }
     *
     **/
    var error = function (argument, message) {
      var argumentName = null;
      var errMessage;
      var err;

      if (argument.getName) {
        argumentName = argument.getName();
      } else {
        argumentName = '' + argument;
      }

      if (!argumentName) {
        errMessage = message;
      } else {
        errMessage = format('argument "%s": %s', argumentName, message);
      }

      err = new TypeError(errMessage);
      err.code = ERR_CODE;
      return err;
    };

    var format$1  = util.format;




    // Constants


    // Errors



    /*:nodoc:*
     * new ChoicesPseudoAction(name, help)
     *
     * Create pseudo action for correct help text
     *
     **/
    function ChoicesPseudoAction(name, help) {
      var options = {
        optionStrings: [],
        dest: name,
        help: help
      };

      action.call(this, options);
    }

    util.inherits(ChoicesPseudoAction, action);

    /**
     * new ActionSubparsers(options)
     * - options (object): options hash see [[Action.new]]
     *
     **/
    function ActionSubparsers(options) {
      options = options || {};
      options.dest = options.dest || _const.SUPPRESS;
      options.nargs = _const.PARSER;

      this.debug = (options.debug === true);

      this._progPrefix = options.prog;
      this._parserClass = options.parserClass;
      this._nameParserMap = {};
      this._choicesActions = [];

      options.choices = this._nameParserMap;
      action.call(this, options);
    }

    util.inherits(ActionSubparsers, action);

    /*:nodoc:*
     * ActionSubparsers#addParser(name, options) -> ArgumentParser
     * - name (string): sub-command name
     * - options (object): see [[ArgumentParser.new]]
     *
     *  Note:
     *  addParser supports an additional aliases option,
     *  which allows multiple strings to refer to the same subparser.
     *  This example, like svn, aliases co as a shorthand for checkout
     *
     **/
    ActionSubparsers.prototype.addParser = function (name, options) {
      var parser;

      var self = this;

      options = options || {};

      options.debug = (this.debug === true);

      // set program from the existing prefix
      if (!options.prog) {
        options.prog = this._progPrefix + ' ' + name;
      }

      var aliases = options.aliases || [];

      // create a pseudo-action to hold the choice help
      if (!!options.help || typeof options.help === 'string') {
        var help = options.help;
        delete options.help;

        var choiceAction = new ChoicesPseudoAction(name, help);
        this._choicesActions.push(choiceAction);
      }

      // create the parser and add it to the map
      parser = new this._parserClass(options);
      this._nameParserMap[name] = parser;

      // make parser available under aliases also
      aliases.forEach(function (alias) {
        self._nameParserMap[alias] = parser;
      });

      return parser;
    };

    ActionSubparsers.prototype._getSubactions = function () {
      return this._choicesActions;
    };

    /*:nodoc:*
     * ActionSubparsers#call(parser, namespace, values, optionString) -> Void
     * - parser (ArgumentParser): current parser
     * - namespace (Namespace): namespace for output data
     * - values (Array): parsed values
     * - optionString (Array): input option string(not parsed)
     *
     * Call the action. Parse input aguments
     **/
    ActionSubparsers.prototype.call = function (parser, namespace, values) {
      var parserName = values[0];
      var argStrings = values.slice(1);

      // set the parser name if requested
      if (this.dest !== _const.SUPPRESS) {
        namespace[this.dest] = parserName;
      }

      // select the parser
      if (this._nameParserMap[parserName]) {
        parser = this._nameParserMap[parserName];
      } else {
        throw error(format$1(
          'Unknown parser "%s" (choices: [%s]).',
            parserName,
            Object.keys(this._nameParserMap).join(', ')
        ));
      }

      // parse all the remaining options into the namespace
      parser.parseArgs(argStrings, namespace);
    };

    var subparsers = ActionSubparsers;

    var group = createCommonjsModule(function (module) {






    /**
     * new ArgumentGroup(container, options)
     * - container (object): main container
     * - options (object): hash of group options
     *
     * #### options
     * - **prefixChars**  group name prefix
     * - **argumentDefault**  default argument value
     * - **title**  group title
     * - **description** group description
     *
     **/
    var ArgumentGroup = module.exports = function ArgumentGroup(container, options) {

      options = options || {};

      // add any missing keyword arguments by checking the container
      options.conflictHandler = (options.conflictHandler || container.conflictHandler);
      options.prefixChars = (options.prefixChars || container.prefixChars);
      options.argumentDefault = (options.argumentDefault || container.argumentDefault);

      action_container.call(this, options);

      // group attributes
      this.title = options.title;
      this._groupActions = [];

      // share most attributes with the container
      this._container = container;
      this._registries = container._registries;
      this._actions = container._actions;
      this._optionStringActions = container._optionStringActions;
      this._defaults = container._defaults;
      this._hasNegativeNumberOptionals = container._hasNegativeNumberOptionals;
      this._mutuallyExclusiveGroups = container._mutuallyExclusiveGroups;
    };
    util.inherits(ArgumentGroup, action_container);


    ArgumentGroup.prototype._addAction = function (action) {
      // Parent add action
      action = action_container.prototype._addAction.call(this, action);
      this._groupActions.push(action);
      return action;
    };


    ArgumentGroup.prototype._removeAction = function (action) {
      // Parent remove action
      action_container.prototype._removeAction.call(this, action);
      var actionIndex = this._groupActions.indexOf(action);
      if (actionIndex >= 0) {
        this._groupActions.splice(actionIndex, 1);
      }
    };
    });

    var exclusive = createCommonjsModule(function (module) {





    /**
     * new MutuallyExclusiveGroup(container, options)
     * - container (object): main container
     * - options (object): options.required -> true/false
     *
     * `required` could be an argument itself, but making it a property of
     * the options argument is more consistent with the JS adaptation of the Python)
     **/
    var MutuallyExclusiveGroup = module.exports = function MutuallyExclusiveGroup(container, options) {
      var required;
      options = options || {};
      required = options.required || false;
      group.call(this, container);
      this.required = required;

    };
    util.inherits(MutuallyExclusiveGroup, group);


    MutuallyExclusiveGroup.prototype._addAction = function (action) {
      var msg;
      if (action.required) {
        msg = 'mutually exclusive arguments must be optional';
        throw new Error(msg);
      }
      action = this._container._addAction(action);
      this._groupActions.push(action);
      return action;
    };


    MutuallyExclusiveGroup.prototype._removeAction = function (action) {
      this._container._removeAction(action);
      this._groupActions.remove(action);
    };
    });

    var action_container = createCommonjsModule(function (module) {

    var format = util.format;

    // Constants




    //Actions











    // Errors


    /**
     * new ActionContainer(options)
     *
     * Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]
     *
     * ##### Options:
     *
     * - `description` -- A description of what the program does
     * - `prefixChars`  -- Characters that prefix optional arguments
     * - `argumentDefault`  -- The default value for all arguments
     * - `conflictHandler` -- The conflict handler to use for duplicate arguments
     **/
    var ActionContainer = module.exports = function ActionContainer(options) {
      options = options || {};

      this.description = options.description;
      this.argumentDefault = options.argumentDefault;
      this.prefixChars = options.prefixChars || '';
      this.conflictHandler = options.conflictHandler;

      // set up registries
      this._registries = {};

      // register actions
      this.register('action', null, store);
      this.register('action', 'store', store);
      this.register('action', 'storeConst', constant$3);
      this.register('action', 'storeTrue', _true);
      this.register('action', 'storeFalse', _false);
      this.register('action', 'append', append);
      this.register('action', 'appendConst', constant$2);
      this.register('action', 'count', count$1);
      this.register('action', 'help', help);
      this.register('action', 'version', version$1);
      this.register('action', 'parsers', subparsers);

      // raise an exception if the conflict handler is invalid
      this._getHandler();

      // action storage
      this._actions = [];
      this._optionStringActions = {};

      // groups
      this._actionGroups = [];
      this._mutuallyExclusiveGroups = [];

      // defaults storage
      this._defaults = {};

      // determines whether an "option" looks like a negative number
      // -1, -1.5 -5e+4
      this._regexpNegativeNumber = new RegExp('^[-]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$');

      // whether or not there are any optionals that look like negative
      // numbers -- uses a list so it can be shared and edited
      this._hasNegativeNumberOptionals = [];
    };

    // Groups must be required, then ActionContainer already defined



    //
    // Registration methods
    //

    /**
     * ActionContainer#register(registryName, value, object) -> Void
     * - registryName (String) : object type action|type
     * - value (string) : keyword
     * - object (Object|Function) : handler
     *
     *  Register handlers
     **/
    ActionContainer.prototype.register = function (registryName, value, object) {
      this._registries[registryName] = this._registries[registryName] || {};
      this._registries[registryName][value] = object;
    };

    ActionContainer.prototype._registryGet = function (registryName, value, defaultValue) {
      if (arguments.length < 3) {
        defaultValue = null;
      }
      return this._registries[registryName][value] || defaultValue;
    };

    //
    // Namespace default accessor methods
    //

    /**
     * ActionContainer#setDefaults(options) -> Void
     * - options (object):hash of options see [[Action.new]]
     *
     * Set defaults
     **/
    ActionContainer.prototype.setDefaults = function (options) {
      options = options || {};
      for (var property in options) {
        if (utils.has(options, property)) {
          this._defaults[property] = options[property];
        }
      }

      // if these defaults match any existing arguments, replace the previous
      // default on the object with the new one
      this._actions.forEach(function (action) {
        if (utils.has(options, action.dest)) {
          action.defaultValue = options[action.dest];
        }
      });
    };

    /**
     * ActionContainer#getDefault(dest) -> Mixed
     * - dest (string): action destination
     *
     * Return action default value
     **/
    ActionContainer.prototype.getDefault = function (dest) {
      var result = utils.has(this._defaults, dest) ? this._defaults[dest] : null;

      this._actions.forEach(function (action) {
        if (action.dest === dest && utils.has(action, 'defaultValue')) {
          result = action.defaultValue;
        }
      });

      return result;
    };
    //
    // Adding argument actions
    //

    /**
     * ActionContainer#addArgument(args, options) -> Object
     * - args (String|Array): argument key, or array of argument keys
     * - options (Object): action objects see [[Action.new]]
     *
     * #### Examples
     * - addArgument([ '-f', '--foo' ], { action: 'store', defaultValue: 1, ... })
     * - addArgument([ 'bar' ], { action: 'store', nargs: 1, ... })
     * - addArgument('--baz', { action: 'store', nargs: 1, ... })
     **/
    ActionContainer.prototype.addArgument = function (args, options) {
      args = args;
      options = options || {};

      if (typeof args === 'string') {
        args = [ args ];
      }
      if (!Array.isArray(args)) {
        throw new TypeError('addArgument first argument should be a string or an array');
      }
      if (typeof options !== 'object' || Array.isArray(options)) {
        throw new TypeError('addArgument second argument should be a hash');
      }

      // if no positional args are supplied or only one is supplied and
      // it doesn't look like an option string, parse a positional argument
      if (!args || args.length === 1 && this.prefixChars.indexOf(args[0][0]) < 0) {
        if (args && !!options.dest) {
          throw new Error('dest supplied twice for positional argument');
        }
        options = this._getPositional(args, options);

        // otherwise, we're adding an optional argument
      } else {
        options = this._getOptional(args, options);
      }

      // if no default was supplied, use the parser-level default
      if (typeof options.defaultValue === 'undefined') {
        var dest = options.dest;
        if (utils.has(this._defaults, dest)) {
          options.defaultValue = this._defaults[dest];
        } else if (typeof this.argumentDefault !== 'undefined') {
          options.defaultValue = this.argumentDefault;
        }
      }

      // create the action object, and add it to the parser
      var ActionClass = this._popActionClass(options);
      if (typeof ActionClass !== 'function') {
        throw new Error(format('Unknown action "%s".', ActionClass));
      }
      var action = new ActionClass(options);

      // throw an error if the action type is not callable
      var typeFunction = this._registryGet('type', action.type, action.type);
      if (typeof typeFunction !== 'function') {
        throw new Error(format('"%s" is not callable', typeFunction));
      }

      return this._addAction(action);
    };

    /**
     * ActionContainer#addArgumentGroup(options) -> ArgumentGroup
     * - options (Object): hash of options see [[ArgumentGroup.new]]
     *
     * Create new arguments groups
     **/
    ActionContainer.prototype.addArgumentGroup = function (options) {
      var group$1 = new group(this, options);
      this._actionGroups.push(group$1);
      return group$1;
    };

    /**
     * ActionContainer#addMutuallyExclusiveGroup(options) -> ArgumentGroup
     * - options (Object): {required: false}
     *
     * Create new mutual exclusive groups
     **/
    ActionContainer.prototype.addMutuallyExclusiveGroup = function (options) {
      var group = new exclusive(this, options);
      this._mutuallyExclusiveGroups.push(group);
      return group;
    };

    ActionContainer.prototype._addAction = function (action) {
      var self = this;

      // resolve any conflicts
      this._checkConflict(action);

      // add to actions list
      this._actions.push(action);
      action.container = this;

      // index the action by any option strings it has
      action.optionStrings.forEach(function (optionString) {
        self._optionStringActions[optionString] = action;
      });

      // set the flag if any option strings look like negative numbers
      action.optionStrings.forEach(function (optionString) {
        if (optionString.match(self._regexpNegativeNumber)) {
          if (!self._hasNegativeNumberOptionals.some(Boolean)) {
            self._hasNegativeNumberOptionals.push(true);
          }
        }
      });

      // return the created action
      return action;
    };

    ActionContainer.prototype._removeAction = function (action) {
      var actionIndex = this._actions.indexOf(action);
      if (actionIndex >= 0) {
        this._actions.splice(actionIndex, 1);
      }
    };

    ActionContainer.prototype._addContainerActions = function (container) {
      // collect groups by titles
      var titleGroupMap = {};
      this._actionGroups.forEach(function (group) {
        if (titleGroupMap[group.title]) {
          throw new Error(format('Cannot merge actions - two groups are named "%s".', group.title));
        }
        titleGroupMap[group.title] = group;
      });

      // map each action to its group
      var groupMap = {};
      function actionHash(action) {
        // unique (hopefully?) string suitable as dictionary key
        return action.getName();
      }
      container._actionGroups.forEach(function (group) {
        // if a group with the title exists, use that, otherwise
        // create a new group matching the container's group
        if (!titleGroupMap[group.title]) {
          titleGroupMap[group.title] = this.addArgumentGroup({
            title: group.title,
            description: group.description
          });
        }

        // map the actions to their new group
        group._groupActions.forEach(function (action) {
          groupMap[actionHash(action)] = titleGroupMap[group.title];
        });
      }, this);

      // add container's mutually exclusive groups
      // NOTE: if add_mutually_exclusive_group ever gains title= and
      // description= then this code will need to be expanded as above
      var mutexGroup;
      container._mutuallyExclusiveGroups.forEach(function (group) {
        mutexGroup = this.addMutuallyExclusiveGroup({
          required: group.required
        });
        // map the actions to their new mutex group
        group._groupActions.forEach(function (action) {
          groupMap[actionHash(action)] = mutexGroup;
        });
      }, this);  // forEach takes a 'this' argument

      // add all actions to this container or their group
      container._actions.forEach(function (action) {
        var key = actionHash(action);
        if (groupMap[key]) {
          groupMap[key]._addAction(action);
        } else {
          this._addAction(action);
        }
      });
    };

    ActionContainer.prototype._getPositional = function (dest, options) {
      if (Array.isArray(dest)) {
        dest = dest[0];
      }
      // make sure required is not specified
      if (options.required) {
        throw new Error('"required" is an invalid argument for positionals.');
      }

      // mark positional arguments as required if at least one is
      // always required
      if (options.nargs !== _const.OPTIONAL && options.nargs !== _const.ZERO_OR_MORE) {
        options.required = true;
      }
      if (options.nargs === _const.ZERO_OR_MORE && typeof options.defaultValue === 'undefined') {
        options.required = true;
      }

      // return the keyword arguments with no option strings
      options.dest = dest;
      options.optionStrings = [];
      return options;
    };

    ActionContainer.prototype._getOptional = function (args, options) {
      var prefixChars = this.prefixChars;
      var optionStrings = [];
      var optionStringsLong = [];

      // determine short and long option strings
      args.forEach(function (optionString) {
        // error on strings that don't start with an appropriate prefix
        if (prefixChars.indexOf(optionString[0]) < 0) {
          throw new Error(format('Invalid option string "%s": must start with a "%s".',
            optionString,
            prefixChars
          ));
        }

        // strings starting with two prefix characters are long options
        optionStrings.push(optionString);
        if (optionString.length > 1 && prefixChars.indexOf(optionString[1]) >= 0) {
          optionStringsLong.push(optionString);
        }
      });

      // infer dest, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
      var dest = options.dest || null;
      delete options.dest;

      if (!dest) {
        var optionStringDest = optionStringsLong.length ? optionStringsLong[0] : optionStrings[0];
        dest = utils.trimChars(optionStringDest, this.prefixChars);

        if (dest.length === 0) {
          throw new Error(
            format('dest= is required for options like "%s"', optionStrings.join(', '))
          );
        }
        dest = dest.replace(/-/g, '_');
      }

      // return the updated keyword arguments
      options.dest = dest;
      options.optionStrings = optionStrings;

      return options;
    };

    ActionContainer.prototype._popActionClass = function (options, defaultValue) {
      defaultValue = defaultValue || null;

      var action = (options.action || defaultValue);
      delete options.action;

      var actionClass = this._registryGet('action', action, action);
      return actionClass;
    };

    ActionContainer.prototype._getHandler = function () {
      var handlerString = this.conflictHandler;
      var handlerFuncName = '_handleConflict' + utils.capitalize(handlerString);
      var func = this[handlerFuncName];
      if (typeof func === 'undefined') {
        var msg = 'invalid conflict resolution value: ' + handlerString;
        throw new Error(msg);
      } else {
        return func;
      }
    };

    ActionContainer.prototype._checkConflict = function (action) {
      var optionStringActions = this._optionStringActions;
      var conflictOptionals = [];

      // find all options that conflict with this option
      // collect pairs, the string, and an existing action that it conflicts with
      action.optionStrings.forEach(function (optionString) {
        var conflOptional = optionStringActions[optionString];
        if (typeof conflOptional !== 'undefined') {
          conflictOptionals.push([ optionString, conflOptional ]);
        }
      });

      if (conflictOptionals.length > 0) {
        var conflictHandler = this._getHandler();
        conflictHandler.call(this, action, conflictOptionals);
      }
    };

    ActionContainer.prototype._handleConflictError = function (action, conflOptionals) {
      var conflicts = conflOptionals.map(function (pair) { return pair[0]; });
      conflicts = conflicts.join(', ');
      throw error(
        action,
        format('Conflicting option string(s): %s', conflicts)
      );
    };

    ActionContainer.prototype._handleConflictResolve = function (action, conflOptionals) {
      // remove all conflicting options
      var self = this;
      conflOptionals.forEach(function (pair) {
        var optionString = pair[0];
        var conflictingAction = pair[1];
        // remove the conflicting option string
        var i = conflictingAction.optionStrings.indexOf(optionString);
        if (i >= 0) {
          conflictingAction.optionStrings.splice(i, 1);
        }
        delete self._optionStringActions[optionString];
        // if the option now has no option string, remove it from the
        // container holding it
        if (conflictingAction.optionStrings.length === 0) {
          conflictingAction.container._removeAction(conflictingAction);
        }
      });
    };
    });

    var formatter = createCommonjsModule(function (module) {

    var sprintf$1 = sprintf.sprintf;

    // Constants





    /*:nodoc:* internal
     * new Support(parent, heding)
     * - parent (object): parent section
     * - heading (string): header string
     *
     **/
    function Section(parent, heading) {
      this._parent = parent;
      this._heading = heading;
      this._items = [];
    }

    /*:nodoc:* internal
     * Section#addItem(callback) -> Void
     * - callback (array): tuple with function and args
     *
     * Add function for single element
     **/
    Section.prototype.addItem = function (callback) {
      this._items.push(callback);
    };

    /*:nodoc:* internal
     * Section#formatHelp(formatter) -> string
     * - formatter (HelpFormatter): current formatter
     *
     * Form help section string
     *
     **/
    Section.prototype.formatHelp = function (formatter) {
      var itemHelp, heading;

      // format the indented section
      if (this._parent) {
        formatter._indent();
      }

      itemHelp = this._items.map(function (item) {
        var obj, func, args;

        obj = formatter;
        func = item[0];
        args = item[1];
        return func.apply(obj, args);
      });
      itemHelp = formatter._joinParts(itemHelp);

      if (this._parent) {
        formatter._dedent();
      }

      // return nothing if the section was empty
      if (!itemHelp) {
        return '';
      }

      // add the heading if the section was non-empty
      heading = '';
      if (this._heading && this._heading !== _const.SUPPRESS) {
        var currentIndent = formatter.currentIndent;
        heading = utils.repeat(' ', currentIndent) + this._heading + ':' + _const.EOL;
      }

      // join the section-initialize newline, the heading and the help
      return formatter._joinParts([ _const.EOL, heading, itemHelp, _const.EOL ]);
    };

    /**
     * new HelpFormatter(options)
     *
     * #### Options:
     * - `prog`: program name
     * - `indentIncriment`: indent step, default value 2
     * - `maxHelpPosition`: max help position, default value = 24
     * - `width`: line width
     *
     **/
    var HelpFormatter = module.exports = function HelpFormatter(options) {
      options = options || {};

      this._prog = options.prog;

      this._maxHelpPosition = options.maxHelpPosition || 24;
      this._width = (options.width || ((process.env.COLUMNS || 80) - 2));

      this._currentIndent = 0;
      this._indentIncriment = options.indentIncriment || 2;
      this._level = 0;
      this._actionMaxLength = 0;

      this._rootSection = new Section(null);
      this._currentSection = this._rootSection;

      this._whitespaceMatcher = new RegExp('\\s+', 'g');
      this._longBreakMatcher = new RegExp(_const.EOL + _const.EOL + _const.EOL + '+', 'g');
    };

    HelpFormatter.prototype._indent = function () {
      this._currentIndent += this._indentIncriment;
      this._level += 1;
    };

    HelpFormatter.prototype._dedent = function () {
      this._currentIndent -= this._indentIncriment;
      this._level -= 1;
      if (this._currentIndent < 0) {
        throw new Error('Indent decreased below 0.');
      }
    };

    HelpFormatter.prototype._addItem = function (func, args) {
      this._currentSection.addItem([ func, args ]);
    };

    //
    // Message building methods
    //

    /**
     * HelpFormatter#startSection(heading) -> Void
     * - heading (string): header string
     *
     * Start new help section
     *
     * See alse [code example][1]
     *
     * ##### Example
     *
     *      formatter.startSection(actionGroup.title);
     *      formatter.addText(actionGroup.description);
     *      formatter.addArguments(actionGroup._groupActions);
     *      formatter.endSection();
     *
     **/
    HelpFormatter.prototype.startSection = function (heading) {
      this._indent();
      var section = new Section(this._currentSection, heading);
      var func = section.formatHelp.bind(section);
      this._addItem(func, [ this ]);
      this._currentSection = section;
    };

    /**
     * HelpFormatter#endSection -> Void
     *
     * End help section
     *
     * ##### Example
     *
     *      formatter.startSection(actionGroup.title);
     *      formatter.addText(actionGroup.description);
     *      formatter.addArguments(actionGroup._groupActions);
     *      formatter.endSection();
     **/
    HelpFormatter.prototype.endSection = function () {
      this._currentSection = this._currentSection._parent;
      this._dedent();
    };

    /**
     * HelpFormatter#addText(text) -> Void
     * - text (string): plain text
     *
     * Add plain text into current section
     *
     * ##### Example
     *
     *      formatter.startSection(actionGroup.title);
     *      formatter.addText(actionGroup.description);
     *      formatter.addArguments(actionGroup._groupActions);
     *      formatter.endSection();
     *
     **/
    HelpFormatter.prototype.addText = function (text) {
      if (text && text !== _const.SUPPRESS) {
        this._addItem(this._formatText, [ text ]);
      }
    };

    /**
     * HelpFormatter#addUsage(usage, actions, groups, prefix) -> Void
     * - usage (string): usage text
     * - actions (array): actions list
     * - groups (array): groups list
     * - prefix (string): usage prefix
     *
     * Add usage data into current section
     *
     * ##### Example
     *
     *      formatter.addUsage(this.usage, this._actions, []);
     *      return formatter.formatHelp();
     *
     **/
    HelpFormatter.prototype.addUsage = function (usage, actions, groups, prefix) {
      if (usage !== _const.SUPPRESS) {
        this._addItem(this._formatUsage, [ usage, actions, groups, prefix ]);
      }
    };

    /**
     * HelpFormatter#addArgument(action) -> Void
     * - action (object): action
     *
     * Add argument into current section
     *
     * Single variant of [[HelpFormatter#addArguments]]
     **/
    HelpFormatter.prototype.addArgument = function (action) {
      if (action.help !== _const.SUPPRESS) {
        var self = this;

        // find all invocations
        var invocations = [ this._formatActionInvocation(action) ];
        var invocationLength = invocations[0].length;

        var actionLength;

        if (action._getSubactions) {
          this._indent();
          action._getSubactions().forEach(function (subaction) {

            var invocationNew = self._formatActionInvocation(subaction);
            invocations.push(invocationNew);
            invocationLength = Math.max(invocationLength, invocationNew.length);

          });
          this._dedent();
        }

        // update the maximum item length
        actionLength = invocationLength + this._currentIndent;
        this._actionMaxLength = Math.max(this._actionMaxLength, actionLength);

        // add the item to the list
        this._addItem(this._formatAction, [ action ]);
      }
    };

    /**
     * HelpFormatter#addArguments(actions) -> Void
     * - actions (array): actions list
     *
     * Mass add arguments into current section
     *
     * ##### Example
     *
     *      formatter.startSection(actionGroup.title);
     *      formatter.addText(actionGroup.description);
     *      formatter.addArguments(actionGroup._groupActions);
     *      formatter.endSection();
     *
     **/
    HelpFormatter.prototype.addArguments = function (actions) {
      var self = this;
      actions.forEach(function (action) {
        self.addArgument(action);
      });
    };

    //
    // Help-formatting methods
    //

    /**
     * HelpFormatter#formatHelp -> string
     *
     * Format help
     *
     * ##### Example
     *
     *      formatter.addText(this.epilog);
     *      return formatter.formatHelp();
     *
     **/
    HelpFormatter.prototype.formatHelp = function () {
      var help = this._rootSection.formatHelp(this);
      if (help) {
        help = help.replace(this._longBreakMatcher, _const.EOL + _const.EOL);
        help = utils.trimChars(help, _const.EOL) + _const.EOL;
      }
      return help;
    };

    HelpFormatter.prototype._joinParts = function (partStrings) {
      return partStrings.filter(function (part) {
        return (part && part !== _const.SUPPRESS);
      }).join('');
    };

    HelpFormatter.prototype._formatUsage = function (usage, actions, groups, prefix) {
      if (!prefix && typeof prefix !== 'string') {
        prefix = 'usage: ';
      }

      actions = actions || [];
      groups = groups || [];


      // if usage is specified, use that
      if (usage) {
        usage = sprintf$1(usage, { prog: this._prog });

        // if no optionals or positionals are available, usage is just prog
      } else if (!usage && actions.length === 0) {
        usage = this._prog;

        // if optionals and positionals are available, calculate usage
      } else if (!usage) {
        var prog = this._prog;
        var optionals = [];
        var positionals = [];
        var actionUsage;
        var textWidth;

        // split optionals from positionals
        actions.forEach(function (action) {
          if (action.isOptional()) {
            optionals.push(action);
          } else {
            positionals.push(action);
          }
        });

        // build full usage string
        actionUsage = this._formatActionsUsage([].concat(optionals, positionals), groups);
        usage = [ prog, actionUsage ].join(' ');

        // wrap the usage parts if it's too long
        textWidth = this._width - this._currentIndent;
        if ((prefix.length + usage.length) > textWidth) {

          // break usage into wrappable parts
          var regexpPart = new RegExp('\\(.*?\\)+|\\[.*?\\]+|\\S+', 'g');
          var optionalUsage = this._formatActionsUsage(optionals, groups);
          var positionalUsage = this._formatActionsUsage(positionals, groups);


          var optionalParts = optionalUsage.match(regexpPart);
          var positionalParts = positionalUsage.match(regexpPart) || [];

          if (optionalParts.join(' ') !== optionalUsage) {
            throw new Error('assert "optionalParts.join(\' \') === optionalUsage"');
          }
          if (positionalParts.join(' ') !== positionalUsage) {
            throw new Error('assert "positionalParts.join(\' \') === positionalUsage"');
          }

          // helper for wrapping lines
          /*eslint-disable func-style*/ // node 0.10 compat
          var _getLines = function (parts, indent, prefix) {
            var lines = [];
            var line = [];

            var lineLength = prefix ? prefix.length - 1 : indent.length - 1;

            parts.forEach(function (part) {
              if (lineLength + 1 + part.length > textWidth) {
                lines.push(indent + line.join(' '));
                line = [];
                lineLength = indent.length - 1;
              }
              line.push(part);
              lineLength += part.length + 1;
            });

            if (line) {
              lines.push(indent + line.join(' '));
            }
            if (prefix) {
              lines[0] = lines[0].substr(indent.length);
            }
            return lines;
          };

          var lines, indent, parts;
          // if prog is short, follow it with optionals or positionals
          if (prefix.length + prog.length <= 0.75 * textWidth) {
            indent = utils.repeat(' ', (prefix.length + prog.length + 1));
            if (optionalParts) {
              lines = [].concat(
                _getLines([ prog ].concat(optionalParts), indent, prefix),
                _getLines(positionalParts, indent)
              );
            } else if (positionalParts) {
              lines = _getLines([ prog ].concat(positionalParts), indent, prefix);
            } else {
              lines = [ prog ];
            }

            // if prog is long, put it on its own line
          } else {
            indent = utils.repeat(' ', prefix.length);
            parts = optionalParts.concat(positionalParts);
            lines = _getLines(parts, indent);
            if (lines.length > 1) {
              lines = [].concat(
                _getLines(optionalParts, indent),
                _getLines(positionalParts, indent)
              );
            }
            lines = [ prog ].concat(lines);
          }
          // join lines into usage
          usage = lines.join(_const.EOL);
        }
      }

      // prefix with 'usage:'
      return prefix + usage + _const.EOL + _const.EOL;
    };

    HelpFormatter.prototype._formatActionsUsage = function (actions, groups) {
      // find group indices and identify actions in groups
      var groupActions = [];
      var inserts = [];
      var self = this;

      groups.forEach(function (group) {
        var end;
        var i;

        var start = actions.indexOf(group._groupActions[0]);
        if (start >= 0) {
          end = start + group._groupActions.length;

          //if (actions.slice(start, end) === group._groupActions) {
          if (utils.arrayEqual(actions.slice(start, end), group._groupActions)) {
            group._groupActions.forEach(function (action) {
              groupActions.push(action);
            });

            if (!group.required) {
              if (inserts[start]) {
                inserts[start] += ' [';
              } else {
                inserts[start] = '[';
              }
              inserts[end] = ']';
            } else {
              if (inserts[start]) {
                inserts[start] += ' (';
              } else {
                inserts[start] = '(';
              }
              inserts[end] = ')';
            }
            for (i = start + 1; i < end; i += 1) {
              inserts[i] = '|';
            }
          }
        }
      });

      // collect all actions format strings
      var parts = [];

      actions.forEach(function (action, actionIndex) {
        var part;
        var optionString;
        var argsDefault;
        var argsString;

        // suppressed arguments are marked with None
        // remove | separators for suppressed arguments
        if (action.help === _const.SUPPRESS) {
          parts.push(null);
          if (inserts[actionIndex] === '|') {
            inserts.splice(actionIndex, actionIndex);
          } else if (inserts[actionIndex + 1] === '|') {
            inserts.splice(actionIndex + 1, actionIndex + 1);
          }

          // produce all arg strings
        } else if (!action.isOptional()) {
          part = self._formatArgs(action, action.dest);

          // if it's in a group, strip the outer []
          if (groupActions.indexOf(action) >= 0) {
            if (part[0] === '[' && part[part.length - 1] === ']') {
              part = part.slice(1, -1);
            }
          }
          // add the action string to the list
          parts.push(part);

        // produce the first way to invoke the option in brackets
        } else {
          optionString = action.optionStrings[0];

          // if the Optional doesn't take a value, format is: -s or --long
          if (action.nargs === 0) {
            part = '' + optionString;

          // if the Optional takes a value, format is: -s ARGS or --long ARGS
          } else {
            argsDefault = action.dest.toUpperCase();
            argsString = self._formatArgs(action, argsDefault);
            part = optionString + ' ' + argsString;
          }
          // make it look optional if it's not required or in a group
          if (!action.required && groupActions.indexOf(action) < 0) {
            part = '[' + part + ']';
          }
          // add the action string to the list
          parts.push(part);
        }
      });

      // insert things at the necessary indices
      for (var i = inserts.length - 1; i >= 0; --i) {
        if (inserts[i] !== null) {
          parts.splice(i, 0, inserts[i]);
        }
      }

      // join all the action items with spaces
      var text = parts.filter(function (part) {
        return !!part;
      }).join(' ');

      // clean up separators for mutually exclusive groups
      text = text.replace(/([\[(]) /g, '$1'); // remove spaces
      text = text.replace(/ ([\])])/g, '$1');
      text = text.replace(/\[ *\]/g, ''); // remove empty groups
      text = text.replace(/\( *\)/g, '');
      text = text.replace(/\(([^|]*)\)/g, '$1'); // remove () from single action groups

      text = text.trim();

      // return the text
      return text;
    };

    HelpFormatter.prototype._formatText = function (text) {
      text = sprintf$1(text, { prog: this._prog });
      var textWidth = this._width - this._currentIndent;
      var indentIncriment = utils.repeat(' ', this._currentIndent);
      return this._fillText(text, textWidth, indentIncriment) + _const.EOL + _const.EOL;
    };

    HelpFormatter.prototype._formatAction = function (action) {
      var self = this;

      var helpText;
      var helpLines;
      var parts;
      var indentFirst;

      // determine the required width and the entry label
      var helpPosition = Math.min(this._actionMaxLength + 2, this._maxHelpPosition);
      var helpWidth = this._width - helpPosition;
      var actionWidth = helpPosition - this._currentIndent - 2;
      var actionHeader = this._formatActionInvocation(action);

      // no help; start on same line and add a final newline
      if (!action.help) {
        actionHeader = utils.repeat(' ', this._currentIndent) + actionHeader + _const.EOL;

      // short action name; start on the same line and pad two spaces
      } else if (actionHeader.length <= actionWidth) {
        actionHeader = utils.repeat(' ', this._currentIndent) +
            actionHeader +
            '  ' +
            utils.repeat(' ', actionWidth - actionHeader.length);
        indentFirst = 0;

      // long action name; start on the next line
      } else {
        actionHeader = utils.repeat(' ', this._currentIndent) + actionHeader + _const.EOL;
        indentFirst = helpPosition;
      }

      // collect the pieces of the action help
      parts = [ actionHeader ];

      // if there was help for the action, add lines of help text
      if (action.help) {
        helpText = this._expandHelp(action);
        helpLines = this._splitLines(helpText, helpWidth);
        parts.push(utils.repeat(' ', indentFirst) + helpLines[0] + _const.EOL);
        helpLines.slice(1).forEach(function (line) {
          parts.push(utils.repeat(' ', helpPosition) + line + _const.EOL);
        });

      // or add a newline if the description doesn't end with one
      } else if (actionHeader.charAt(actionHeader.length - 1) !== _const.EOL) {
        parts.push(_const.EOL);
      }
      // if there are any sub-actions, add their help as well
      if (action._getSubactions) {
        this._indent();
        action._getSubactions().forEach(function (subaction) {
          parts.push(self._formatAction(subaction));
        });
        this._dedent();
      }
      // return a single string
      return this._joinParts(parts);
    };

    HelpFormatter.prototype._formatActionInvocation = function (action) {
      if (!action.isOptional()) {
        var format_func = this._metavarFormatter(action, action.dest);
        var metavars = format_func(1);
        return metavars[0];
      }

      var parts = [];
      var argsDefault;
      var argsString;

      // if the Optional doesn't take a value, format is: -s, --long
      if (action.nargs === 0) {
        parts = parts.concat(action.optionStrings);

      // if the Optional takes a value, format is: -s ARGS, --long ARGS
      } else {
        argsDefault = action.dest.toUpperCase();
        argsString = this._formatArgs(action, argsDefault);
        action.optionStrings.forEach(function (optionString) {
          parts.push(optionString + ' ' + argsString);
        });
      }
      return parts.join(', ');
    };

    HelpFormatter.prototype._metavarFormatter = function (action, metavarDefault) {
      var result;

      if (action.metavar || action.metavar === '') {
        result = action.metavar;
      } else if (action.choices) {
        var choices = action.choices;

        if (typeof choices === 'string') {
          choices = choices.split('').join(', ');
        } else if (Array.isArray(choices)) {
          choices = choices.join(',');
        } else {
          choices = Object.keys(choices).join(',');
        }
        result = '{' + choices + '}';
      } else {
        result = metavarDefault;
      }

      return function (size) {
        if (Array.isArray(result)) {
          return result;
        }

        var metavars = [];
        for (var i = 0; i < size; i += 1) {
          metavars.push(result);
        }
        return metavars;
      };
    };

    HelpFormatter.prototype._formatArgs = function (action, metavarDefault) {
      var result;
      var metavars;

      var buildMetavar = this._metavarFormatter(action, metavarDefault);

      switch (action.nargs) {
        /*eslint-disable no-undefined*/
        case undefined:
        case null:
          metavars = buildMetavar(1);
          result = '' + metavars[0];
          break;
        case _const.OPTIONAL:
          metavars = buildMetavar(1);
          result = '[' + metavars[0] + ']';
          break;
        case _const.ZERO_OR_MORE:
          metavars = buildMetavar(2);
          result = '[' + metavars[0] + ' [' + metavars[1] + ' ...]]';
          break;
        case _const.ONE_OR_MORE:
          metavars = buildMetavar(2);
          result = '' + metavars[0] + ' [' + metavars[1] + ' ...]';
          break;
        case _const.REMAINDER:
          result = '...';
          break;
        case _const.PARSER:
          metavars = buildMetavar(1);
          result = metavars[0] + ' ...';
          break;
        default:
          metavars = buildMetavar(action.nargs);
          result = metavars.join(' ');
      }
      return result;
    };

    HelpFormatter.prototype._expandHelp = function (action) {
      var params = { prog: this._prog };

      Object.keys(action).forEach(function (actionProperty) {
        var actionValue = action[actionProperty];

        if (actionValue !== _const.SUPPRESS) {
          params[actionProperty] = actionValue;
        }
      });

      if (params.choices) {
        if (typeof params.choices === 'string') {
          params.choices = params.choices.split('').join(', ');
        } else if (Array.isArray(params.choices)) {
          params.choices = params.choices.join(', ');
        } else {
          params.choices = Object.keys(params.choices).join(', ');
        }
      }

      return sprintf$1(this._getHelpString(action), params);
    };

    HelpFormatter.prototype._splitLines = function (text, width) {
      var lines = [];
      var delimiters = [ ' ', '.', ',', '!', '?' ];
      var re = new RegExp('[' + delimiters.join('') + '][^' + delimiters.join('') + ']*$');

      text = text.replace(/[\n\|\t]/g, ' ');

      text = text.trim();
      text = text.replace(this._whitespaceMatcher, ' ');

      // Wraps the single paragraph in text (a string) so every line
      // is at most width characters long.
      text.split(_const.EOL).forEach(function (line) {
        if (width >= line.length) {
          lines.push(line);
          return;
        }

        var wrapStart = 0;
        var wrapEnd = width;
        var delimiterIndex = 0;
        while (wrapEnd <= line.length) {
          if (wrapEnd !== line.length && delimiters.indexOf(line[wrapEnd] < -1)) {
            delimiterIndex = (re.exec(line.substring(wrapStart, wrapEnd)) || {}).index;
            wrapEnd = wrapStart + delimiterIndex + 1;
          }
          lines.push(line.substring(wrapStart, wrapEnd));
          wrapStart = wrapEnd;
          wrapEnd += width;
        }
        if (wrapStart < line.length) {
          lines.push(line.substring(wrapStart, wrapEnd));
        }
      });

      return lines;
    };

    HelpFormatter.prototype._fillText = function (text, width, indent) {
      var lines = this._splitLines(text, width);
      lines = lines.map(function (line) {
        return indent + line;
      });
      return lines.join(_const.EOL);
    };

    HelpFormatter.prototype._getHelpString = function (action) {
      return action.help;
    };
    });

    var namespace = createCommonjsModule(function (module) {



    /**
     * new Namespace(options)
     * - options(object): predefined propertis for result object
     *
     **/
    var Namespace = module.exports = function Namespace(options) {
      utils.extend(this, options);
    };

    /**
     * Namespace#isset(key) -> Boolean
     * - key (string|number): property name
     *
     * Tells whenever `namespace` contains given `key` or not.
     **/
    Namespace.prototype.isset = function (key) {
      return utils.has(this, key);
    };

    /**
     * Namespace#set(key, value) -> self
     * -key (string|number|object): propery name
     * -value (mixed): new property value
     *
     * Set the property named key with value.
     * If key object then set all key properties to namespace object
     **/
    Namespace.prototype.set = function (key, value) {
      if (typeof (key) === 'object') {
        utils.extend(this, key);
      } else {
        this[key] = value;
      }
      return this;
    };

    /**
     * Namespace#get(key, defaultValue) -> mixed
     * - key (string|number): property name
     * - defaultValue (mixed): default value
     *
     * Return the property key or defaulValue if not set
     **/
    Namespace.prototype.get = function (key, defaultValue) {
      return !this[key] ? defaultValue : this[key];
    };

    /**
     * Namespace#unset(key, defaultValue) -> mixed
     * - key (string|number): property name
     * - defaultValue (mixed): default value
     *
     * Return data[key](and delete it) or defaultValue
     **/
    Namespace.prototype.unset = function (key, defaultValue) {
      var value = this[key];
      if (value !== null) {
        delete this[key];
        return value;
      }
      return defaultValue;
    };
    });

    var format$2  = util.format;

    var sprintf$1 = sprintf.sprintf;

    // Constants






    // Errors







    /**
     * new ArgumentParser(options)
     *
     * Create a new ArgumentParser object.
     *
     * ##### Options:
     * - `prog`  The name of the program (default: Path.basename(process.argv[1]))
     * - `usage`  A usage message (default: auto-generated from arguments)
     * - `description`  A description of what the program does
     * - `epilog`  Text following the argument descriptions
     * - `parents`  Parsers whose arguments should be copied into this one
     * - `formatterClass`  HelpFormatter class for printing help messages
     * - `prefixChars`  Characters that prefix optional arguments
     * - `fromfilePrefixChars` Characters that prefix files containing additional arguments
     * - `argumentDefault`  The default value for all arguments
     * - `addHelp`  Add a -h/-help option
     * - `conflictHandler`  Specifies how to handle conflicting argument names
     * - `debug`  Enable debug mode. Argument errors throw exception in
     *   debug mode and process.exit in normal. Used for development and
     *   testing (default: false)
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects
     **/
    function ArgumentParser(options) {
      if (!(this instanceof ArgumentParser)) {
        return new ArgumentParser(options);
      }
      var self = this;
      options = options || {};

      options.description = (options.description || null);
      options.argumentDefault = (options.argumentDefault || null);
      options.prefixChars = (options.prefixChars || '-');
      options.conflictHandler = (options.conflictHandler || 'error');
      action_container.call(this, options);

      options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;
      options.parents = options.parents || [];
      // default program name
      options.prog = (options.prog || path.basename(process.argv[1]));
      this.prog = options.prog;
      this.usage = options.usage;
      this.epilog = options.epilog;
      this.version = options.version;

      this.debug = (options.debug === true);

      this.formatterClass = (options.formatterClass || formatter);
      this.fromfilePrefixChars = options.fromfilePrefixChars || null;
      this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });
      this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });
      this._subparsers = null;

      // register types
      function FUNCTION_IDENTITY(o) {
        return o;
      }
      this.register('type', 'auto', FUNCTION_IDENTITY);
      this.register('type', null, FUNCTION_IDENTITY);
      this.register('type', 'int', function (x) {
        var result = parseInt(x, 10);
        if (isNaN(result)) {
          throw new Error(x + ' is not a valid integer.');
        }
        return result;
      });
      this.register('type', 'float', function (x) {
        var result = parseFloat(x);
        if (isNaN(result)) {
          throw new Error(x + ' is not a valid float.');
        }
        return result;
      });
      this.register('type', 'string', function (x) {
        return '' + x;
      });

      // add help and version arguments if necessary
      var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];
      if (options.addHelp) {
        this.addArgument(
          [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],
          {
            action: 'help',
            defaultValue: _const.SUPPRESS,
            help: 'Show this help message and exit.'
          }
        );
      }
      if (typeof this.version !== 'undefined') {
        this.addArgument(
          [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],
          {
            action: 'version',
            version: this.version,
            defaultValue: _const.SUPPRESS,
            help: "Show program's version number and exit."
          }
        );
      }

      // add parent arguments and defaults
      options.parents.forEach(function (parent) {
        self._addContainerActions(parent);
        if (typeof parent._defaults !== 'undefined') {
          for (var defaultKey in parent._defaults) {
            if (parent._defaults.hasOwnProperty(defaultKey)) {
              self._defaults[defaultKey] = parent._defaults[defaultKey];
            }
          }
        }
      });
    }

    util.inherits(ArgumentParser, action_container);

    /**
     * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]
     * - options (object): hash of options see [[ActionSubparsers.new]]
     *
     * See also [subcommands][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands
     **/
    ArgumentParser.prototype.addSubparsers = function (options) {
      if (this._subparsers) {
        this.error('Cannot have multiple subparser arguments.');
      }

      options = options || {};
      options.debug = (this.debug === true);
      options.optionStrings = [];
      options.parserClass = (options.parserClass || ArgumentParser);


      if (!!options.title || !!options.description) {

        this._subparsers = this.addArgumentGroup({
          title: (options.title || 'subcommands'),
          description: options.description
        });
        delete options.title;
        delete options.description;

      } else {
        this._subparsers = this._positionals;
      }

      // prog defaults to the usage message of this parser, skipping
      // optional arguments and with no "usage:" prefix
      if (!options.prog) {
        var formatter = this._getFormatter();
        var positionals = this._getPositionalActions();
        var groups = this._mutuallyExclusiveGroups;
        formatter.addUsage(this.usage, positionals, groups, '');
        options.prog = formatter.formatHelp().trim();
      }

      // create the parsers action and add it to the positionals list
      var ParsersClass = this._popActionClass(options, 'parsers');
      var action = new ParsersClass(options);
      this._subparsers._addAction(action);

      // return the created parsers action
      return action;
    };

    ArgumentParser.prototype._addAction = function (action) {
      if (action.isOptional()) {
        this._optionals._addAction(action);
      } else {
        this._positionals._addAction(action);
      }
      return action;
    };

    ArgumentParser.prototype._getOptionalActions = function () {
      return this._actions.filter(function (action) {
        return action.isOptional();
      });
    };

    ArgumentParser.prototype._getPositionalActions = function () {
      return this._actions.filter(function (action) {
        return action.isPositional();
      });
    };


    /**
     * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object
     * - args (array): input elements
     * - namespace (Namespace|Object): result object
     *
     * Parsed args and throws error if some arguments are not recognized
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method
     **/
    ArgumentParser.prototype.parseArgs = function (args, namespace) {
      var argv;
      var result = this.parseKnownArgs(args, namespace);

      args = result[0];
      argv = result[1];
      if (argv && argv.length > 0) {
        this.error(
          format$2('Unrecognized arguments: %s.', argv.join(' '))
        );
      }
      return args;
    };

    /**
     * ArgumentParser#parseKnownArgs(args, namespace) -> array
     * - args (array): input options
     * - namespace (Namespace|Object): result object
     *
     * Parse known arguments and return tuple of result object
     * and unknown args
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing
     **/
    ArgumentParser.prototype.parseKnownArgs = function (args, namespace$1) {
      var self = this;

      // args default to the system args
      args = args || process.argv.slice(2);

      // default Namespace built from parser defaults
      namespace$1 = namespace$1 || new namespace();

      self._actions.forEach(function (action) {
        if (action.dest !== _const.SUPPRESS) {
          if (!utils.has(namespace$1, action.dest)) {
            if (action.defaultValue !== _const.SUPPRESS) {
              var defaultValue = action.defaultValue;
              if (typeof action.defaultValue === 'string') {
                defaultValue = self._getValue(action, defaultValue);
              }
              namespace$1[action.dest] = defaultValue;
            }
          }
        }
      });

      Object.keys(self._defaults).forEach(function (dest) {
        namespace$1[dest] = self._defaults[dest];
      });

      // parse the arguments and exit if there are any errors
      try {
        var res = this._parseKnownArgs(args, namespace$1);

        namespace$1 = res[0];
        args = res[1];
        if (utils.has(namespace$1, _const._UNRECOGNIZED_ARGS_ATTR)) {
          args = utils.arrayUnion(args, namespace$1[_const._UNRECOGNIZED_ARGS_ATTR]);
          delete namespace$1[_const._UNRECOGNIZED_ARGS_ATTR];
        }
        return [ namespace$1, args ];
      } catch (e) {
        this.error(e);
      }
    };

    ArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {
      var self = this;

      var extras = [];

      // replace arg strings that are file references
      if (this.fromfilePrefixChars !== null) {
        argStrings = this._readArgsFromFiles(argStrings);
      }
      // map all mutually exclusive arguments to the other arguments
      // they can't occur with
      // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'
      // though I can't conceive of a way in which an action could be a member
      // of two different mutually exclusive groups.

      function actionHash(action) {
        // some sort of hashable key for this action
        // action itself cannot be a key in actionConflicts
        // I think getName() (join of optionStrings) is unique enough
        return action.getName();
      }

      var conflicts, key;
      var actionConflicts = {};

      this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {
        mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {
          key = actionHash(mutexAction);
          if (!utils.has(actionConflicts, key)) {
            actionConflicts[key] = [];
          }
          conflicts = actionConflicts[key];
          conflicts.push.apply(conflicts, groupActions.slice(0, i));
          conflicts.push.apply(conflicts, groupActions.slice(i + 1));
        });
      });

      // find all option indices, and determine the arg_string_pattern
      // which has an 'O' if there is an option at an index,
      // an 'A' if there is an argument, or a '-' if there is a '--'
      var optionStringIndices = {};

      var argStringPatternParts = [];

      argStrings.forEach(function (argString, argStringIndex) {
        if (argString === '--') {
          argStringPatternParts.push('-');
          while (argStringIndex < argStrings.length) {
            argStringPatternParts.push('A');
            argStringIndex++;
          }
        } else {
          // otherwise, add the arg to the arg strings
          // and note the index if it was an option
          var pattern;
          var optionTuple = self._parseOptional(argString);
          if (!optionTuple) {
            pattern = 'A';
          } else {
            optionStringIndices[argStringIndex] = optionTuple;
            pattern = 'O';
          }
          argStringPatternParts.push(pattern);
        }
      });
      var argStringsPattern = argStringPatternParts.join('');

      var seenActions = [];
      var seenNonDefaultActions = [];


      function takeAction(action, argumentStrings, optionString) {
        seenActions.push(action);
        var argumentValues = self._getValues(action, argumentStrings);

        // error if this argument is not allowed with other previously
        // seen arguments, assuming that actions that use the default
        // value don't really count as "present"
        if (argumentValues !== action.defaultValue) {
          seenNonDefaultActions.push(action);
          if (actionConflicts[actionHash(action)]) {
            actionConflicts[actionHash(action)].forEach(function (actionConflict) {
              if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {
                throw error(
                  action,
                  format$2('Not allowed with argument "%s".', actionConflict.getName())
                );
              }
            });
          }
        }

        if (argumentValues !== _const.SUPPRESS) {
          action.call(self, namespace, argumentValues, optionString);
        }
      }

      function consumeOptional(startIndex) {
        // get the optional identified at this index
        var optionTuple = optionStringIndices[startIndex];
        var action = optionTuple[0];
        var optionString = optionTuple[1];
        var explicitArg = optionTuple[2];

        // identify additional optionals in the same arg string
        // (e.g. -xyz is the same as -x -y -z if no args are required)
        var actionTuples = [];

        var args, argCount, start, stop;

        for (;;) {
          if (!action) {
            extras.push(argStrings[startIndex]);
            return startIndex + 1;
          }
          if (explicitArg) {
            argCount = self._matchArgument(action, 'A');

            // if the action is a single-dash option and takes no
            // arguments, try to parse more single-dash options out
            // of the tail of the option string
            var chars = self.prefixChars;
            if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {
              actionTuples.push([ action, [], optionString ]);
              optionString = optionString[0] + explicitArg[0];
              var newExplicitArg = explicitArg.slice(1) || null;
              var optionalsMap = self._optionStringActions;

              if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {
                action = optionalsMap[optionString];
                explicitArg = newExplicitArg;
              } else {
                throw error(action, sprintf$1('ignored explicit argument %r', explicitArg));
              }
            } else if (argCount === 1) {
              // if the action expect exactly one argument, we've
              // successfully matched the option; exit the loop
              stop = startIndex + 1;
              args = [ explicitArg ];
              actionTuples.push([ action, args, optionString ]);
              break;
            } else {
              // error if a double-dash option did not use the
              // explicit argument
              throw error(action, sprintf$1('ignored explicit argument %r', explicitArg));
            }
          } else {
            // if there is no explicit argument, try to match the
            // optional's string arguments with the following strings
            // if successful, exit the loop

            start = startIndex + 1;
            var selectedPatterns = argStringsPattern.substr(start);

            argCount = self._matchArgument(action, selectedPatterns);
            stop = start + argCount;


            args = argStrings.slice(start, stop);

            actionTuples.push([ action, args, optionString ]);
            break;
          }

        }

        // add the Optional to the list and return the index at which
        // the Optional's string args stopped
        if (actionTuples.length < 1) {
          throw new Error('length should be > 0');
        }
        for (var i = 0; i < actionTuples.length; i++) {
          takeAction.apply(self, actionTuples[i]);
        }
        return stop;
      }

      // the list of Positionals left to be parsed; this is modified
      // by consume_positionals()
      var positionals = self._getPositionalActions();

      function consumePositionals(startIndex) {
        // match as many Positionals as possible
        var selectedPattern = argStringsPattern.substr(startIndex);
        var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);

        // slice off the appropriate arg strings for each Positional
        // and add the Positional and its args to the list
        for (var i = 0; i < positionals.length; i++) {
          var action = positionals[i];
          var argCount = argCounts[i];
          if (typeof argCount === 'undefined') {
            continue;
          }
          var args = argStrings.slice(startIndex, startIndex + argCount);

          startIndex += argCount;
          takeAction(action, args);
        }

        // slice off the Positionals that we just parsed and return the
        // index at which the Positionals' string args stopped
        positionals = positionals.slice(argCounts.length);
        return startIndex;
      }

      // consume Positionals and Optionals alternately, until we have
      // passed the last option string
      var startIndex = 0;
      var position;

      var maxOptionStringIndex = -1;

      Object.keys(optionStringIndices).forEach(function (position) {
        maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));
      });

      var positionalsEndIndex, nextOptionStringIndex;

      while (startIndex <= maxOptionStringIndex) {
        // consume any Positionals preceding the next option
        nextOptionStringIndex = null;
        for (position in optionStringIndices) {
          if (!optionStringIndices.hasOwnProperty(position)) { continue; }

          position = parseInt(position, 10);
          if (position >= startIndex) {
            if (nextOptionStringIndex !== null) {
              nextOptionStringIndex = Math.min(nextOptionStringIndex, position);
            } else {
              nextOptionStringIndex = position;
            }
          }
        }

        if (startIndex !== nextOptionStringIndex) {
          positionalsEndIndex = consumePositionals(startIndex);
          // only try to parse the next optional if we didn't consume
          // the option string during the positionals parsing
          if (positionalsEndIndex > startIndex) {
            startIndex = positionalsEndIndex;
            continue;
          } else {
            startIndex = positionalsEndIndex;
          }
        }

        // if we consumed all the positionals we could and we're not
        // at the index of an option string, there were extra arguments
        if (!optionStringIndices[startIndex]) {
          var strings = argStrings.slice(startIndex, nextOptionStringIndex);
          extras = extras.concat(strings);
          startIndex = nextOptionStringIndex;
        }
        // consume the next optional and any arguments for it
        startIndex = consumeOptional(startIndex);
      }

      // consume any positionals following the last Optional
      var stopIndex = consumePositionals(startIndex);

      // if we didn't consume all the argument strings, there were extras
      extras = extras.concat(argStrings.slice(stopIndex));

      // if we didn't use all the Positional objects, there were too few
      // arg strings supplied.
      if (positionals.length > 0) {
        self.error('too few arguments');
      }

      // make sure all required actions were present
      self._actions.forEach(function (action) {
        if (action.required) {
          if (seenActions.indexOf(action) < 0) {
            self.error(format$2('Argument "%s" is required', action.getName()));
          }
        }
      });

      // make sure all required groups have one option present
      var actionUsed = false;
      self._mutuallyExclusiveGroups.forEach(function (group) {
        if (group.required) {
          actionUsed = group._groupActions.some(function (action) {
            return seenNonDefaultActions.indexOf(action) !== -1;
          });

          // if no actions were used, report the error
          if (!actionUsed) {
            var names = [];
            group._groupActions.forEach(function (action) {
              if (action.help !== _const.SUPPRESS) {
                names.push(action.getName());
              }
            });
            names = names.join(' ');
            var msg = 'one of the arguments ' + names + ' is required';
            self.error(msg);
          }
        }
      });

      // return the updated namespace and the extra arguments
      return [ namespace, extras ];
    };

    ArgumentParser.prototype._readArgsFromFiles = function (argStrings) {
      // expand arguments referencing files
      var self = this;
      var fs = fs__default;
      var newArgStrings = [];
      argStrings.forEach(function (argString) {
        if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {
          // for regular arguments, just add them back into the list
          newArgStrings.push(argString);
        } else {
          // replace arguments referencing files with the file content
          try {
            var argstrs = [];
            var filename = argString.slice(1);
            var content = fs.readFileSync(filename, 'utf8');
            content = content.trim().split('\n');
            content.forEach(function (argLine) {
              self.convertArgLineToArgs(argLine).forEach(function (arg) {
                argstrs.push(arg);
              });
              argstrs = self._readArgsFromFiles(argstrs);
            });
            newArgStrings.push.apply(newArgStrings, argstrs);
          } catch (error) {
            return self.error(error.message);
          }
        }
      });
      return newArgStrings;
    };

    ArgumentParser.prototype.convertArgLineToArgs = function (argLine) {
      return [ argLine ];
    };

    ArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {

      // match the pattern for this action to the arg strings
      var regexpNargs = new RegExp('^' + this._getNargsPattern(action));
      var matches = regexpArgStrings.match(regexpNargs);
      var message;

      // throw an exception if we weren't able to find a match
      if (!matches) {
        switch (action.nargs) {
          /*eslint-disable no-undefined*/
          case undefined:
          case null:
            message = 'Expected one argument.';
            break;
          case _const.OPTIONAL:
            message = 'Expected at most one argument.';
            break;
          case _const.ONE_OR_MORE:
            message = 'Expected at least one argument.';
            break;
          default:
            message = 'Expected %s argument(s)';
        }

        throw error(
          action,
          format$2(message, action.nargs)
        );
      }
      // return the number of arguments matched
      return matches[1].length;
    };

    ArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {
      // progressively shorten the actions list by slicing off the
      // final actions until we find a match
      var self = this;
      var result = [];
      var actionSlice, pattern, matches;
      var i, j;

      function getLength(string) {
        return string.length;
      }

      for (i = actions.length; i > 0; i--) {
        pattern = '';
        actionSlice = actions.slice(0, i);
        for (j = 0; j < actionSlice.length; j++) {
          pattern += self._getNargsPattern(actionSlice[j]);
        }

        pattern = new RegExp('^' + pattern);
        matches = regexpArgStrings.match(pattern);

        if (matches && matches.length > 0) {
          // need only groups
          matches = matches.splice(1);
          result = result.concat(matches.map(getLength));
          break;
        }
      }

      // return the list of arg string counts
      return result;
    };

    ArgumentParser.prototype._parseOptional = function (argString) {
      var action, optionString, argExplicit, optionTuples;

      // if it's an empty string, it was meant to be a positional
      if (!argString) {
        return null;
      }

      // if it doesn't start with a prefix, it was meant to be positional
      if (this.prefixChars.indexOf(argString[0]) < 0) {
        return null;
      }

      // if the option string is present in the parser, return the action
      if (this._optionStringActions[argString]) {
        return [ this._optionStringActions[argString], argString, null ];
      }

      // if it's just a single character, it was meant to be positional
      if (argString.length === 1) {
        return null;
      }

      // if the option string before the "=" is present, return the action
      if (argString.indexOf('=') >= 0) {
        optionString = argString.split('=', 1)[0];
        argExplicit = argString.slice(optionString.length + 1);

        if (this._optionStringActions[optionString]) {
          action = this._optionStringActions[optionString];
          return [ action, optionString, argExplicit ];
        }
      }

      // search through all possible prefixes of the option string
      // and all actions in the parser for possible interpretations
      optionTuples = this._getOptionTuples(argString);

      // if multiple actions match, the option string was ambiguous
      if (optionTuples.length > 1) {
        var optionStrings = optionTuples.map(function (optionTuple) {
          return optionTuple[1];
        });
        this.error(format$2(
              'Ambiguous option: "%s" could match %s.',
              argString, optionStrings.join(', ')
        ));
      // if exactly one action matched, this segmentation is good,
      // so return the parsed action
      } else if (optionTuples.length === 1) {
        return optionTuples[0];
      }

      // if it was not found as an option, but it looks like a negative
      // number, it was meant to be positional
      // unless there are negative-number-like options
      if (argString.match(this._regexpNegativeNumber)) {
        if (!this._hasNegativeNumberOptionals.some(Boolean)) {
          return null;
        }
      }
      // if it contains a space, it was meant to be a positional
      if (argString.search(' ') >= 0) {
        return null;
      }

      // it was meant to be an optional but there is no such option
      // in this parser (though it might be a valid option in a subparser)
      return [ null, argString, null ];
    };

    ArgumentParser.prototype._getOptionTuples = function (optionString) {
      var result = [];
      var chars = this.prefixChars;
      var optionPrefix;
      var argExplicit;
      var action;
      var actionOptionString;

      // option strings starting with two prefix characters are only split at
      // the '='
      if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {
        if (optionString.indexOf('=') >= 0) {
          var optionStringSplit = optionString.split('=', 1);

          optionPrefix = optionStringSplit[0];
          argExplicit = optionStringSplit[1];
        } else {
          optionPrefix = optionString;
          argExplicit = null;
        }

        for (actionOptionString in this._optionStringActions) {
          if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
            action = this._optionStringActions[actionOptionString];
            result.push([ action, actionOptionString, argExplicit ]);
          }
        }

      // single character options can be concatenated with their arguments
      // but multiple character options always have to have their argument
      // separate
      } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {
        optionPrefix = optionString;
        argExplicit = null;
        var optionPrefixShort = optionString.substr(0, 2);
        var argExplicitShort = optionString.substr(2);

        for (actionOptionString in this._optionStringActions) {
          if (!utils.has(this._optionStringActions, actionOptionString)) continue;

          action = this._optionStringActions[actionOptionString];
          if (actionOptionString === optionPrefixShort) {
            result.push([ action, actionOptionString, argExplicitShort ]);
          } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
            result.push([ action, actionOptionString, argExplicit ]);
          }
        }

      // shouldn't ever get here
      } else {
        throw new Error(format$2('Unexpected option string: %s.', optionString));
      }
      // return the collected option tuples
      return result;
    };

    ArgumentParser.prototype._getNargsPattern = function (action) {
      // in all examples below, we have to allow for '--' args
      // which are represented as '-' in the pattern
      var regexpNargs;

      switch (action.nargs) {
        // the default (null) is assumed to be a single argument
        case undefined:
        case null:
          regexpNargs = '(-*A-*)';
          break;
        // allow zero or more arguments
        case _const.OPTIONAL:
          regexpNargs = '(-*A?-*)';
          break;
        // allow zero or more arguments
        case _const.ZERO_OR_MORE:
          regexpNargs = '(-*[A-]*)';
          break;
        // allow one or more arguments
        case _const.ONE_OR_MORE:
          regexpNargs = '(-*A[A-]*)';
          break;
        // allow any number of options or arguments
        case _const.REMAINDER:
          regexpNargs = '([-AO]*)';
          break;
        // allow one argument followed by any number of options or arguments
        case _const.PARSER:
          regexpNargs = '(-*A[-AO]*)';
          break;
        // all others should be integers
        default:
          regexpNargs = '(-*' + utils.repeat('-*A', action.nargs) + '-*)';
      }

      // if this is an optional action, -- is not allowed
      if (action.isOptional()) {
        regexpNargs = regexpNargs.replace(/-\*/g, '');
        regexpNargs = regexpNargs.replace(/-/g, '');
      }

      // return the pattern
      return regexpNargs;
    };

    //
    // Value conversion methods
    //

    ArgumentParser.prototype._getValues = function (action, argStrings) {
      var self = this;

      // for everything but PARSER args, strip out '--'
      if (action.nargs !== _const.PARSER && action.nargs !== _const.REMAINDER) {
        argStrings = argStrings.filter(function (arrayElement) {
          return arrayElement !== '--';
        });
      }

      var value, argString;

      // optional argument produces a default when not present
      if (argStrings.length === 0 && action.nargs === _const.OPTIONAL) {

        value = (action.isOptional()) ? action.constant : action.defaultValue;

        if (typeof (value) === 'string') {
          value = this._getValue(action, value);
          this._checkValue(action, value);
        }

      // when nargs='*' on a positional, if there were no command-line
      // args, use the default if it is anything other than None
      } else if (argStrings.length === 0 && action.nargs === _const.ZERO_OR_MORE &&
        action.optionStrings.length === 0) {

        value = (action.defaultValue || argStrings);
        this._checkValue(action, value);

      // single argument or optional argument produces a single value
      } else if (argStrings.length === 1 &&
            (!action.nargs || action.nargs === _const.OPTIONAL)) {

        argString = argStrings[0];
        value = this._getValue(action, argString);
        this._checkValue(action, value);

      // REMAINDER arguments convert all values, checking none
      } else if (action.nargs === _const.REMAINDER) {
        value = argStrings.map(function (v) {
          return self._getValue(action, v);
        });

      // PARSER arguments convert all values, but check only the first
      } else if (action.nargs === _const.PARSER) {
        value = argStrings.map(function (v) {
          return self._getValue(action, v);
        });
        this._checkValue(action, value[0]);

      // all other types of nargs produce a list
      } else {
        value = argStrings.map(function (v) {
          return self._getValue(action, v);
        });
        value.forEach(function (v) {
          self._checkValue(action, v);
        });
      }

      // return the converted value
      return value;
    };

    ArgumentParser.prototype._getValue = function (action, argString) {
      var result;

      var typeFunction = this._registryGet('type', action.type, action.type);
      if (typeof typeFunction !== 'function') {
        var message = format$2('%s is not callable', typeFunction);
        throw error(action, message);
      }

      // convert the value to the appropriate type
      try {
        result = typeFunction(argString);

        // ArgumentTypeErrors indicate errors
        // If action.type is not a registered string, it is a function
        // Try to deduce its name for inclusion in the error message
        // Failing that, include the error message it raised.
      } catch (e) {
        var name = null;
        if (typeof action.type === 'string') {
          name = action.type;
        } else {
          name = action.type.name || action.type.displayName || '<function>';
        }
        var msg = format$2('Invalid %s value: %s', name, argString);
        if (name === '<function>') { msg += '\n' + e.message; }
        throw error(action, msg);
      }
      // return the converted value
      return result;
    };

    ArgumentParser.prototype._checkValue = function (action, value) {
      // converted value must be one of the choices (if specified)
      var choices = action.choices;
      if (choices) {
        // choise for argument can by array or string
        if ((typeof choices === 'string' || Array.isArray(choices)) &&
            choices.indexOf(value) !== -1) {
          return;
        }
        // choise for subparsers can by only hash
        if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {
          return;
        }

        if (typeof choices === 'string') {
          choices = choices.split('').join(', ');
        } else if (Array.isArray(choices)) {
          choices =  choices.join(', ');
        } else {
          choices =  Object.keys(choices).join(', ');
        }
        var message = format$2('Invalid choice: %s (choose from [%s])', value, choices);
        throw error(action, message);
      }
    };

    //
    // Help formatting methods
    //

    /**
     * ArgumentParser#formatUsage -> string
     *
     * Return usage string
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
     **/
    ArgumentParser.prototype.formatUsage = function () {
      var formatter = this._getFormatter();
      formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);
      return formatter.formatHelp();
    };

    /**
     * ArgumentParser#formatHelp -> string
     *
     * Return help
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
     **/
    ArgumentParser.prototype.formatHelp = function () {
      var formatter = this._getFormatter();

      // usage
      formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);

      // description
      formatter.addText(this.description);

      // positionals, optionals and user-defined groups
      this._actionGroups.forEach(function (actionGroup) {
        formatter.startSection(actionGroup.title);
        formatter.addText(actionGroup.description);
        formatter.addArguments(actionGroup._groupActions);
        formatter.endSection();
      });

      // epilog
      formatter.addText(this.epilog);

      // determine help from format above
      return formatter.formatHelp();
    };

    ArgumentParser.prototype._getFormatter = function () {
      var FormatterClass = this.formatterClass;
      var formatter = new FormatterClass({ prog: this.prog });
      return formatter;
    };

    //
    //  Print functions
    //

    /**
     * ArgumentParser#printUsage() -> Void
     *
     * Print usage
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
     **/
    ArgumentParser.prototype.printUsage = function () {
      this._printMessage(this.formatUsage());
    };

    /**
     * ArgumentParser#printHelp() -> Void
     *
     * Print help
     *
     * See also [original guide][1]
     *
     * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
     **/
    ArgumentParser.prototype.printHelp = function () {
      this._printMessage(this.formatHelp());
    };

    ArgumentParser.prototype._printMessage = function (message, stream) {
      if (!stream) {
        stream = process.stdout;
      }
      if (message) {
        stream.write('' + message);
      }
    };

    //
    //  Exit functions
    //

    /**
     * ArgumentParser#exit(status=0, message) -> Void
     * - status (int): exit status
     * - message (string): message
     *
     * Print message in stderr/stdout and exit program
     **/
    ArgumentParser.prototype.exit = function (status, message) {
      if (message) {
        if (status === 0) {
          this._printMessage(message);
        } else {
          this._printMessage(message, process.stderr);
        }
      }

      process.exit(status);
    };

    /**
     * ArgumentParser#error(message) -> Void
     * - err (Error|string): message
     *
     * Error method Prints a usage message incorporating the message to stderr and
     * exits. If you override this in a subclass,
     * it should not return -- it should
     * either exit or throw an exception.
     *
     **/
    ArgumentParser.prototype.error = function (err) {
      var message;
      if (err instanceof Error) {
        if (this.debug === true) {
          throw err;
        }
        message = err.message;
      } else {
        message = err;
      }
      var msg = format$2('%s: error: %s', this.prog, message) + _const.EOL;

      if (this.debug === true) {
        throw new Error(msg);
      }

      this.printUsage(process.stderr);

      return this.exit(2, msg);
    };

    var argument_parser = ArgumentParser;

    // Constants





    /**
     * new RawDescriptionHelpFormatter(options)
     * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})
     *
     * Help message formatter which adds default values to argument help.
     *
     * Only the name of this class is considered a public API. All the methods
     * provided by the class are considered an implementation detail.
     **/

    function ArgumentDefaultsHelpFormatter(options) {
      formatter.call(this, options);
    }

    util.inherits(ArgumentDefaultsHelpFormatter, formatter);

    ArgumentDefaultsHelpFormatter.prototype._getHelpString = function (action) {
      var help = action.help;
      if (action.help.indexOf('%(defaultValue)s') === -1) {
        if (action.defaultValue !== _const.SUPPRESS) {
          var defaulting_nargs = [ _const.OPTIONAL, _const.ZERO_OR_MORE ];
          if (action.isOptional() || (defaulting_nargs.indexOf(action.nargs) >= 0)) {
            help += ' (default: %(defaultValue)s)';
          }
        }
      }
      return help;
    };

    var ArgumentDefaultsHelpFormatter_1 = ArgumentDefaultsHelpFormatter;

    /**
     * new RawDescriptionHelpFormatter(options)
     * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})
     *
     * Help message formatter which retains any formatting in descriptions.
     *
     * Only the name of this class is considered a public API. All the methods
     * provided by the class are considered an implementation detail.
     **/

    function RawDescriptionHelpFormatter(options) {
      formatter.call(this, options);
    }

    util.inherits(RawDescriptionHelpFormatter, formatter);

    RawDescriptionHelpFormatter.prototype._fillText = function (text, width, indent) {
      var lines = text.split('\n');
      lines = lines.map(function (line) {
        return utils.trimEnd(indent + line);
      });
      return lines.join('\n');
    };
    var RawDescriptionHelpFormatter_1 = RawDescriptionHelpFormatter;

    /**
     * new RawTextHelpFormatter(options)
     * new ArgumentParser({formatterClass: argparse.RawTextHelpFormatter, ...})
     *
     * Help message formatter which retains formatting of all help text.
     *
     * Only the name of this class is considered a public API. All the methods
     * provided by the class are considered an implementation detail.
     **/

    function RawTextHelpFormatter(options) {
      RawDescriptionHelpFormatter.call(this, options);
    }

    util.inherits(RawTextHelpFormatter, RawDescriptionHelpFormatter);

    RawTextHelpFormatter.prototype._splitLines = function (text) {
      return text.split('\n');
    };

    var RawTextHelpFormatter_1 = RawTextHelpFormatter;

    var added_formatters = {
    	ArgumentDefaultsHelpFormatter: ArgumentDefaultsHelpFormatter_1,
    	RawDescriptionHelpFormatter: RawDescriptionHelpFormatter_1,
    	RawTextHelpFormatter: RawTextHelpFormatter_1
    };

    var ArgumentParser$1 = argument_parser;
    var Namespace = namespace;
    var Action = action;
    var HelpFormatter = formatter;
    var Const = _const;

    var ArgumentDefaultsHelpFormatter$1 =
      added_formatters.ArgumentDefaultsHelpFormatter;
    var RawDescriptionHelpFormatter$1 =
      added_formatters.RawDescriptionHelpFormatter;
    var RawTextHelpFormatter$1 =
      added_formatters.RawTextHelpFormatter;

    var argparse = {
    	ArgumentParser: ArgumentParser$1,
    	Namespace: Namespace,
    	Action: Action,
    	HelpFormatter: HelpFormatter,
    	Const: Const,
    	ArgumentDefaultsHelpFormatter: ArgumentDefaultsHelpFormatter$1,
    	RawDescriptionHelpFormatter: RawDescriptionHelpFormatter$1,
    	RawTextHelpFormatter: RawTextHelpFormatter$1
    };

    var argparse$1 = argparse;

    var styles_1 = createCommonjsModule(function (module) {
    /*
    The MIT License (MIT)

    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.

    */

    var styles = {};
    module['exports'] = styles;

    var codes = {
      reset: [0, 0],

      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],

      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],

      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],

      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49],

    };

    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = '\u001b[' + val[0] + 'm';
      style.close = '\u001b[' + val[1] + 'm';
    });
    });

    /*
    MIT License

    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    */

    var hasFlag = function(flag, argv) {
      argv = argv || process.argv;

      var terminatorPos = argv.indexOf('--');
      var prefix = /^-{1,2}/.test(flag) ? '' : '--';
      var pos = argv.indexOf(prefix + flag);

      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };

    var env = process.env;

    var forceColor = void 0;
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
      forceColor = false;
    } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')
               || hasFlag('color=always')) {
      forceColor = true;
    }
    if ('FORCE_COLOR' in env) {
      forceColor = env.FORCE_COLOR.length === 0
        || parseInt(env.FORCE_COLOR, 10) !== 0;
    }

    function translateLevel(level) {
      if (level === 0) {
        return false;
      }

      return {
        level: level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3,
      };
    }

    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }

      if (hasFlag('color=16m') || hasFlag('color=full')
          || hasFlag('color=truecolor')) {
        return 3;
      }

      if (hasFlag('color=256')) {
        return 2;
      }

      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }

      var min = forceColor ? 1 : 0;

      if (process.platform === 'win32') {
        // Node.js 7.5.0 is the first version of Node.js to include a patch to
        // libuv that enables 256 color output on Windows. Anything earlier and it
        // won't work. However, here we target Node.js 8 at minimum as it is an LTS
        // release, and Node.js 7 is not. Windows 10 build 10586 is the first
        // Windows release that supports 256 colors. Windows 10 build 14931 is the
        // first release that supports 16m/TrueColor.
        var osRelease = os.release().split('.');
        if (Number(process.versions.node.split('.')[0]) >= 8
            && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }

        return 1;
      }

      if ('CI' in env) {
        if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === 'codeship') {
          return 1;
        }

        return min;
      }

      if ('TEAMCITY_VERSION' in env) {
        return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
        );
      }

      if ('TERM_PROGRAM' in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

        switch (env.TERM_PROGRAM) {
          case 'iTerm.app':
            return version >= 3 ? 3 : 2;
          case 'Hyper':
            return 3;
          case 'Apple_Terminal':
            return 2;
          // No default
        }
      }

      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }

      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }

      if ('COLORTERM' in env) {
        return 1;
      }

      if (env.TERM === 'dumb') {
        return min;
      }

      return min;
    }

    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }

    var supportsColors = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr),
    };

    var trap = createCommonjsModule(function (module) {
    module['exports'] = function runTheTrap(text, options) {
      var result = '';
      text = text || 'Run the trap, drop the bass';
      text = text.split('');
      var trap = {
        a: ['\u0040', '\u0104', '\u023a', '\u0245', '\u0394', '\u039b', '\u0414'],
        b: ['\u00df', '\u0181', '\u0243', '\u026e', '\u03b2', '\u0e3f'],
        c: ['\u00a9', '\u023b', '\u03fe'],
        d: ['\u00d0', '\u018a', '\u0500', '\u0501', '\u0502', '\u0503'],
        e: ['\u00cb', '\u0115', '\u018e', '\u0258', '\u03a3', '\u03be', '\u04bc',
             '\u0a6c'],
        f: ['\u04fa'],
        g: ['\u0262'],
        h: ['\u0126', '\u0195', '\u04a2', '\u04ba', '\u04c7', '\u050a'],
        i: ['\u0f0f'],
        j: ['\u0134'],
        k: ['\u0138', '\u04a0', '\u04c3', '\u051e'],
        l: ['\u0139'],
        m: ['\u028d', '\u04cd', '\u04ce', '\u0520', '\u0521', '\u0d69'],
        n: ['\u00d1', '\u014b', '\u019d', '\u0376', '\u03a0', '\u048a'],
        o: ['\u00d8', '\u00f5', '\u00f8', '\u01fe', '\u0298', '\u047a', '\u05dd',
             '\u06dd', '\u0e4f'],
        p: ['\u01f7', '\u048e'],
        q: ['\u09cd'],
        r: ['\u00ae', '\u01a6', '\u0210', '\u024c', '\u0280', '\u042f'],
        s: ['\u00a7', '\u03de', '\u03df', '\u03e8'],
        t: ['\u0141', '\u0166', '\u0373'],
        u: ['\u01b1', '\u054d'],
        v: ['\u05d8'],
        w: ['\u0428', '\u0460', '\u047c', '\u0d70'],
        x: ['\u04b2', '\u04fe', '\u04fc', '\u04fd'],
        y: ['\u00a5', '\u04b0', '\u04cb'],
        z: ['\u01b5', '\u0240'],
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [' '];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== 'undefined') {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
    });

    var zalgo = createCommonjsModule(function (module) {
    // please no
    module['exports'] = function zalgo(text, options) {
      text = text || '   he is here   ';
      var soul = {
        'up': [
          '̍', '̎', '̄', '̅',
          '̿', '̑', '̆', '̐',
          '͒', '͗', '͑', '̇',
          '̈', '̊', '͂', '̓',
          '̈', '͊', '͋', '͌',
          '̃', '̂', '̌', '͐',
          '̀', '́', '̋', '̏',
          '̒', '̓', '̔', '̽',
          '̉', 'ͣ', 'ͤ', 'ͥ',
          'ͦ', 'ͧ', 'ͨ', 'ͩ',
          'ͪ', 'ͫ', 'ͬ', 'ͭ',
          'ͮ', 'ͯ', '̾', '͛',
          '͆', '̚',
        ],
        'down': [
          '̖', '̗', '̘', '̙',
          '̜', '̝', '̞', '̟',
          '̠', '̤', '̥', '̦',
          '̩', '̪', '̫', '̬',
          '̭', '̮', '̯', '̰',
          '̱', '̲', '̳', '̹',
          '̺', '̻', '̼', 'ͅ',
          '͇', '͈', '͉', '͍',
          '͎', '͓', '͔', '͕',
          '͖', '͙', '͚', '̣',
        ],
        'mid': [
          '̕', '̛', '̀', '́',
          '͘', '̡', '̢', '̧',
          '̨', '̴', '̵', '̶',
          '͜', '͝', '͞',
          '͟', '͠', '͢', '̸',
          '̷', '͡', ' ҉',
        ],
      };
      var all = [].concat(soul.up, soul.down, soul.mid);

      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }

      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = (i === character);
        });
        return bool;
      }


      function heComes(text, options) {
        var result = '';
        var counts;
        var l;
        options = options || {};
        options['up'] =
          typeof options['up'] !== 'undefined' ? options['up'] : true;
        options['mid'] =
          typeof options['mid'] !== 'undefined' ? options['mid'] : true;
        options['down'] =
          typeof options['down'] !== 'undefined' ? options['down'] : true;
        options['size'] =
          typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';
        text = text.split('');
        for (l in text) {
          if (isChar(l)) {
            continue;
          }
          result = result + text[l];
          counts = {'up': 0, 'down': 0, 'mid': 0};
          switch (options.size) {
          case 'mini':
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case 'maxi':
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
          }

          var arr = ['up', 'mid', 'down'];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      // don't summon him
      return heComes(text, options);
    };
    });

    var america = createCommonjsModule(function (module) {
    module['exports'] = (function() {
      return function(letter, i, exploded) {
        if (letter === ' ') return letter;
        switch (i%3) {
          case 0: return colors_1.red(letter);
          case 1: return colors_1.white(letter);
          case 2: return colors_1.blue(letter);
        }
      };
    })();
    });

    var zebra = createCommonjsModule(function (module) {
    module['exports'] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors_1.inverse(letter);
    };
    });

    var rainbow = createCommonjsModule(function (module) {
    module['exports'] = (function() {
      // RoY G BiV
      var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
      return function(letter, i, exploded) {
        if (letter === ' ') {
          return letter;
        } else {
          return colors_1[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    })();
    });

    var random = createCommonjsModule(function (module) {
    module['exports'] = (function() {
      var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',
        'blue', 'white', 'cyan', 'magenta'];
      return function(letter, i, exploded) {
        return letter === ' ' ? letter :
          colors_1[
            available[Math.round(Math.random() * (available.length - 2))]
          ](letter);
      };
    })();
    });

    var colors_1 = createCommonjsModule(function (module) {
    /*

    The MIT License (MIT)

    Original Library
      - Copyright (c) Marak Squires

    Additional functionality
     - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.

    */

    var colors = {};
    module['exports'] = colors;

    colors.themes = {};


    var ansiStyles = colors.styles = styles_1;
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);

    colors.supportsColor = supportsColors.supportsColor;

    if (typeof colors.enabled === 'undefined') {
      colors.enabled = colors.supportsColor() !== false;
    }

    colors.enable = function() {
      colors.enabled = true;
    };

    colors.disable = function() {
      colors.enabled = false;
    };

    colors.stripColors = colors.strip = function(str) {
      return ('' + str).replace(/\x1B\[\d+m/g, '');
    };

    // eslint-disable-next-line no-unused-vars
    var stylize = colors.stylize = function stylize(str, style) {
      if (!colors.enabled) {
        return str+'';
      }

      return ansiStyles[style].open + str + ansiStyles[style].close;
    };

    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }
      return str.replace(matchOperatorsRe, '\\$&');
    };

    function build(_styles) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      // __proto__ is used because we must return a function, but there is
      // no way to create a function with a different prototype.
      builder.__proto__ = proto;
      return builder;
    }

    var styles = (function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe =
          new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          },
        };
      });
      return ret;
    })();

    var proto = defineProps(function colors() {}, styles);

    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);

      var str = args.map(function(arg) {
        if (arg !== undefined && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(' ');

      if (!colors.enabled || !str) {
        return str;
      }

      var newLinesPresent = str.indexOf('\n') != -1;

      var nestedStyles = this._styles;

      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, code.close + '\n' + code.open);
        }
      }

      return str;
    }

    colors.setTheme = function(theme) {
      if (typeof theme === 'string') {
        console.log('colors.setTheme now only accepts an object, not a string.  ' +
          'If you are trying to set a theme from a file, it is now your (the ' +
          'caller\'s) responsibility to require the file.  The old syntax ' +
          'looked like colors.setTheme(__dirname + ' +
          '\'/../themes/generic-logging.js\'); The new syntax looks like '+
          'colors.setTheme(require(__dirname + ' +
          '\'/../themes/generic-logging.js\'));');
        return;
      }
      for (var style in theme) {
        (function(style) {
          colors[style] = function(str) {
            if (typeof theme[style] === 'object') {
              var out = str;
              for (var i in theme[style]) {
                out = colors[theme[style][i]](out);
              }
              return out;
            }
            return colors[theme[style]](str);
          };
        })(style);
      }
    };

    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          },
        };
      });
      return ret;
    }

    var sequencer = function sequencer(map, str) {
      var exploded = str.split('');
      exploded = exploded.map(map);
      return exploded.join('');
    };

    // custom formatter methods
    colors.trap = trap;
    colors.zalgo = zalgo;

    // maps
    colors.maps = {};
    colors.maps.america = america;
    colors.maps.zebra = zebra;
    colors.maps.rainbow = rainbow;
    colors.maps.random = random;

    for (var map in colors.maps) {
      (function(map) {
        colors[map] = function(str) {
          return sequencer(colors.maps[map], str);
        };
      })(map);
    }

    defineProps(colors, init());
    });

    var extendStringPrototype = createCommonjsModule(function (module) {
    module['exports'] = function() {
      //
      // Extends prototype of native string object to allow for "foo".red syntax
      //
      var addProperty = function(color, func) {
        String.prototype.__defineGetter__(color, func);
      };

      addProperty('strip', function() {
        return colors_1.strip(this);
      });

      addProperty('stripColors', function() {
        return colors_1.strip(this);
      });

      addProperty('trap', function() {
        return colors_1.trap(this);
      });

      addProperty('zalgo', function() {
        return colors_1.zalgo(this);
      });

      addProperty('zebra', function() {
        return colors_1.zebra(this);
      });

      addProperty('rainbow', function() {
        return colors_1.rainbow(this);
      });

      addProperty('random', function() {
        return colors_1.random(this);
      });

      addProperty('america', function() {
        return colors_1.america(this);
      });

      //
      // Iterate through all default styles and colors
      //
      var x = Object.keys(colors_1.styles);
      x.forEach(function(style) {
        addProperty(style, function() {
          return colors_1.stylize(this, style);
        });
      });

      function applyTheme(theme) {
        //
        // Remark: This is a list of methods that exist
        // on String that you should not overwrite.
        //
        var stringPrototypeBlacklist = [
          '__defineGetter__', '__defineSetter__', '__lookupGetter__',
          '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty',
          'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString',
          'valueOf', 'charCodeAt', 'indexOf', 'lastIndexOf', 'length',
          'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice',
          'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase',
          'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight',
        ];

        Object.keys(theme).forEach(function(prop) {
          if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
            console.log('warn: '.red + ('String.prototype' + prop).magenta +
              ' is probably something you don\'t want to override.  ' +
              'Ignoring style name');
          } else {
            if (typeof(theme[prop]) === 'string') {
              colors_1[prop] = colors_1[theme[prop]];
              addProperty(prop, function() {
                return colors_1[theme[prop]](this);
              });
            } else {
              addProperty(prop, function() {
                var ret = this;
                for (var t = 0; t < theme[prop].length; t++) {
                  ret = colors_1[theme[prop][t]](ret);
                }
                return ret;
              });
            }
          }
        });
      }

      colors_1.setTheme = function(theme) {
        if (typeof theme === 'string') {
          try {
            colors_1.themes[theme] = commonjsRequire(theme);
            applyTheme(colors_1.themes[theme]);
            return colors_1.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
    };
    });

    var lib = createCommonjsModule(function (module) {
    module['exports'] = colors_1;

    // Remark: By default, colors will add style properties to String.prototype.
    //
    // If you don't wish to extend String.prototype, you can do this instead and
    // native String will not be touched:
    //
    //   var colors = require('colors/safe);
    //   colors.red("foo")
    //
    //
    extendStringPrototype();
    });

    var CommandLineParser_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });



    class CommandLineParserExitError extends Error {
        constructor(exitCode, message) {
            super(message);
            // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
            // tslint:disable-next-line:max-line-length
            // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            //
            // Note: the prototype must also be set on any classes which extend this one
            this.__proto__ = CommandLineParserExitError.prototype; // tslint:disable-line:no-any
            this.exitCode = exitCode;
        }
    }
    exports.CommandLineParserExitError = CommandLineParserExitError;
    class CustomArgumentParser extends argparse$1.ArgumentParser {
        exit(status, message) {
            throw new CommandLineParserExitError(status, message);
        }
        error(err) {
            // Ensure the ParserExitError bubbles up to the top without any special processing
            if (err instanceof CommandLineParserExitError) {
                throw err;
            }
            super.error(err);
        }
    }
    /**
     * The "argparse" library is a relatively advanced command-line parser with features such
     * as word-wrapping and intelligible error messages (that are lacking in other similar
     * libraries such as commander, yargs, and nomnom).  Unfortunately, its ruby-inspired API
     * is awkward to use.  The abstract base classes CommandLineParser and CommandLineAction
     * provide a wrapper for "argparse" that makes defining and consuming arguments quick
     * and simple, and enforces that appropriate documentation is provided for each parameter.
     *
     * @public
     */
    class CommandLineParser extends CommandLineParameterProvider_1.CommandLineParameterProvider {
        constructor(options) {
            super();
            this._executed = false;
            this._options = options;
            this._actions = [];
            this._actionsByName = new Map();
            this._argumentParser = new CustomArgumentParser({
                addHelp: true,
                prog: this._options.toolFilename,
                description: this._options.toolDescription,
                epilog: lib.bold('For detailed help about a specific command, use:'
                    + ` ${this._options.toolFilename} <command> -h`)
            });
            this._actionsSubParser = this._argumentParser.addSubparsers({
                metavar: '<command>',
                dest: 'action'
            });
            this.onDefineParameters();
        }
        /**
         * Returns the list of actions that were defined for this CommandLineParser object.
         */
        get actions() {
            return this._actions;
        }
        /**
         * Defines a new action that can be used with the CommandLineParser instance.
         */
        addAction(action) {
            action._buildParser(this._actionsSubParser);
            this._actions.push(action);
            this._actionsByName.set(action.actionName, action);
        }
        /**
         * Retrieves the action with the specified name.  If no matching action is found,
         * an exception is thrown.
         */
        getAction(actionName) {
            const action = this.tryGetAction(actionName);
            if (!action) {
                throw new Error(`The action "${actionName}" was not defined`);
            }
            return action;
        }
        /**
         * Retrieves the action with the specified name.  If no matching action is found,
         * undefined is returned.
         */
        tryGetAction(actionName) {
            return this._actionsByName.get(actionName);
        }
        /**
         * The program entry point will call this method to begin parsing command-line arguments
         * and executing the corresponding action.
         *
         * @remarks
         * The returned promise will never reject:  If an error occurs, it will be printed
         * to stderr, process.exitCode will be set to 1, and the promise will resolve to false.
         * This simplifies the most common usage scenario where the program entry point doesn't
         * want to be involved with the command-line logic, and will discard the promise without
         * a then() or catch() block.
         *
         * If your caller wants to trap and handle errors, use {@link CommandLineParser.executeWithoutErrorHandling}
         * instead.
         *
         * @param args - the command-line arguments to be parsed; if omitted, then
         *               the process.argv will be used
         */
        execute(args) {
            return this.executeWithoutErrorHandling(args).then(() => {
                return true;
            }).catch((err) => {
                if (err instanceof CommandLineParserExitError) {
                    // executeWithoutErrorHandling() handles the successful cases,
                    // so here we can assume err has a nonzero exit code
                    if (err.message) {
                        console.error(err.message);
                    }
                    if (!process.exitCode) {
                        process.exitCode = err.exitCode;
                    }
                }
                else {
                    const message = (err.message || 'An unknown error occurred').trim();
                    console.error(lib.red('Error: ' + message));
                    if (!process.exitCode) {
                        process.exitCode = 1;
                    }
                }
                return false;
            });
        }
        /**
         * This is similar to {@link CommandLineParser.execute}, except that execution errors
         * simply cause the promise to reject.  It is the caller's responsibility to trap
         */
        executeWithoutErrorHandling(args) {
            try {
                if (this._executed) {
                    // In the future we could allow the same parser to be invoked multiple times
                    // with different arguments.  We'll do that work as soon as someone encounters
                    // a real world need for it.
                    throw new Error('execute() was already called for this parser instance');
                }
                this._executed = true;
                if (!args) {
                    // 0=node.exe, 1=script name
                    args = process.argv.slice(2);
                }
                if (args.length === 0) {
                    this._argumentParser.printHelp();
                    return Promise.resolve();
                }
                const data = this._argumentParser.parseArgs(args);
                this._processParsedData(data);
                for (const action of this._actions) {
                    if (action.actionName === data.action) {
                        this.selectedAction = action;
                        action._processParsedData(data);
                        break;
                    }
                }
                if (!this.selectedAction) {
                    throw new Error('Unrecognized action');
                }
                return this.onExecute();
            }
            catch (err) {
                if (err instanceof CommandLineParserExitError) {
                    if (!err.exitCode) {
                        // non-error exit modeled using exception handling
                        if (err.message) {
                            console.log(err.message);
                        }
                        return Promise.resolve();
                    }
                }
                return Promise.reject(err);
            }
        }
        /**
         * {@inheritDoc CommandLineParameterProvider._getArgumentParser}
         * @internal
         */
        _getArgumentParser() {
            return this._argumentParser;
        }
        /**
         * This hook allows the subclass to perform additional operations before or after
         * the chosen action is executed.
         */
        onExecute() {
            return this.selectedAction._execute();
        }
    }
    exports.CommandLineParser = CommandLineParser;

    });

    unwrapExports(CommandLineParser_1);
    var CommandLineParser_2 = CommandLineParser_1.CommandLineParserExitError;
    var CommandLineParser_3 = CommandLineParser_1.CommandLineParser;

    var DynamicCommandLineAction_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * @public
     */
    class DynamicCommandLineAction extends CommandLineAction_1.CommandLineAction {
        onDefineParameters() {
            // (handled by the external code)
        }
        onExecute() {
            // (handled by the external code)
            return Promise.resolve();
        }
    }
    exports.DynamicCommandLineAction = DynamicCommandLineAction;

    });

    unwrapExports(DynamicCommandLineAction_1);
    var DynamicCommandLineAction_2 = DynamicCommandLineAction_1.DynamicCommandLineAction;

    var DynamicCommandLineParser_1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * @public
     */
    class DynamicCommandLineParser extends CommandLineParser_1.CommandLineParser {
        onDefineParameters() {
        }
    }
    exports.DynamicCommandLineParser = DynamicCommandLineParser;

    });

    unwrapExports(DynamicCommandLineParser_1);
    var DynamicCommandLineParser_2 = DynamicCommandLineParser_1.DynamicCommandLineParser;

    var lib$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
    // See LICENSE in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An object-oriented command-line parser for TypeScript projects.
     *
     * @packageDocumentation
     */

    exports.CommandLineAction = CommandLineAction_1.CommandLineAction;

    exports.CommandLineParameterKind = CommandLineParameter_1.CommandLineParameterKind;
    exports.CommandLineParameter = CommandLineParameter_1.CommandLineParameter;
    exports.CommandLineParameterWithArgument = CommandLineParameter_1.CommandLineParameterWithArgument;
    exports.CommandLineStringParameter = CommandLineParameter_1.CommandLineStringParameter;
    exports.CommandLineStringListParameter = CommandLineParameter_1.CommandLineStringListParameter;
    exports.CommandLineFlagParameter = CommandLineParameter_1.CommandLineFlagParameter;
    exports.CommandLineIntegerParameter = CommandLineParameter_1.CommandLineIntegerParameter;
    exports.CommandLineChoiceParameter = CommandLineParameter_1.CommandLineChoiceParameter;

    exports.CommandLineParameterProvider = CommandLineParameterProvider_1.CommandLineParameterProvider;

    exports.CommandLineParser = CommandLineParser_1.CommandLineParser;

    exports.DynamicCommandLineAction = DynamicCommandLineAction_1.DynamicCommandLineAction;

    exports.DynamicCommandLineParser = DynamicCommandLineParser_1.DynamicCommandLineParser;

    });

    unwrapExports(lib$1);
    var lib_1 = lib$1.CommandLineAction;
    var lib_2 = lib$1.CommandLineParameterKind;
    var lib_3 = lib$1.CommandLineParameter;
    var lib_4 = lib$1.CommandLineParameterWithArgument;
    var lib_5 = lib$1.CommandLineStringParameter;
    var lib_6 = lib$1.CommandLineStringListParameter;
    var lib_7 = lib$1.CommandLineFlagParameter;
    var lib_8 = lib$1.CommandLineIntegerParameter;
    var lib_9 = lib$1.CommandLineChoiceParameter;
    var lib_10 = lib$1.CommandLineParameterProvider;
    var lib_11 = lib$1.CommandLineParser;
    var lib_12 = lib$1.DynamicCommandLineAction;
    var lib_13 = lib$1.DynamicCommandLineParser;

    class PrintAction extends lib_1 {
        constructor() {
            super({
                actionName: "print",
                summary: "Print information about an Oakfile.",
                documentation: "TODO"
            });
        }
        onExecute() {
            oak_print({ filename: this._filename.value });
            return Promise.resolve();
        }
        onDefineParameters() {
            this._filename = this.defineStringParameter({
                argumentName: "FILENAME",
                parameterLongName: "--file",
                parameterShortName: "-f",
                description: "Path to Oakfile.",
                defaultValue: "./Oakfile"
            });
        }
    }
    class StaticAction extends lib_1 {
        constructor() {
            super({
                actionName: "static",
                summary: "Statically run an Oakfile.",
                documentation: "TODO"
            });
        }
        onExecute() {
            oak_static({
                filename: this._filename.value
                // TODO add ability to only build provided targets
                // targets: this._targets.values
            });
            return Promise.resolve();
        }
        onDefineParameters() {
            this._filename = this.defineStringParameter({
                argumentName: "FILENAME",
                parameterLongName: "--file",
                parameterShortName: "-f",
                description: "Path to Oakfile.",
                defaultValue: "./Oakfile"
            });
            this._targets = this.defineStringListParameter({
                argumentName: "TARGETS",
                parameterLongName: "--targets",
                parameterShortName: "-t",
                description: "List of target names to resolve."
            });
        }
    }
    class OakCommandLine extends lib_11 {
        constructor() {
            super({
                toolFilename: "oak",
                toolDescription: "CLI for oak."
            });
            this.addAction(new PrintAction());
            this.addAction(new StaticAction());
        }
        onDefineParameters() { }
        onExecute() {
            console.log("OakCommandLine executing...");
            return super.onExecute();
        }
    }
    const cli = new OakCommandLine();
    cli.execute();

}(child_process, events, fs, util, path, os));
